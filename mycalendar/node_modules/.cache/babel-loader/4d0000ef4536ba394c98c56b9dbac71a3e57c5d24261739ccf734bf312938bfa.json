{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  AsyncSeriesBailHook,\n  AsyncSeriesHook,\n  SyncHook\n} = require(\"tapable\");\nconst createInnerContext = require(\"./createInnerContext\");\nconst {\n  parseIdentifier\n} = require(\"./util/identifier\");\nconst {\n  PathType,\n  cachedJoin: join,\n  getType,\n  normalize\n} = require(\"./util/path\");\n\n/** @typedef {import(\"./ResolverFactory\").ResolveOptions} ResolveOptions */\n\n/** @typedef {Error & { details?: string }} ErrorWithDetail */\n\n/** @typedef {(err: ErrorWithDetail | null, res?: string | false, req?: ResolveRequest) => void} ResolveCallback */\n\n/**\n * @typedef {object} PossibleFileSystemError\n * @property {string=} code code\n * @property {number=} errno number\n * @property {string=} path path\n * @property {string=} syscall syscall\n */\n\n/**\n * @template T\n * @callback FileSystemCallback\n * @param {PossibleFileSystemError & Error | null} err\n * @param {T=} result\n */\n\n/**\n * @typedef {string | Buffer | URL} PathLike\n */\n\n/**\n * @typedef {PathLike | number} PathOrFileDescriptor\n */\n\n/**\n * @typedef {object} ObjectEncodingOptions\n * @property {BufferEncoding | null | undefined=} encoding encoding\n */\n\n/**\n * @typedef {ObjectEncodingOptions | BufferEncoding | undefined | null} EncodingOption\n */\n\n/** @typedef {(err: NodeJS.ErrnoException | null, result?: string) => void} StringCallback */\n/** @typedef {(err: NodeJS.ErrnoException | null, result?: Buffer) => void} BufferCallback */\n/** @typedef {(err: NodeJS.ErrnoException | null, result?: (string | Buffer)) => void} StringOrBufferCallback */\n/** @typedef {(err: NodeJS.ErrnoException | null, result?: IStats) => void} StatsCallback */\n/** @typedef {(err: NodeJS.ErrnoException | null, result?: IBigIntStats) => void} BigIntStatsCallback */\n/** @typedef {(err: NodeJS.ErrnoException | null, result?: (IStats | IBigIntStats)) => void} StatsOrBigIntStatsCallback */\n/** @typedef {(err: NodeJS.ErrnoException | Error | null, result?: JsonObject) => void} ReadJsonCallback */\n\n/**\n * @template T\n * @typedef {object} IStatsBase\n * @property {() => boolean} isFile is file\n * @property {() => boolean} isDirectory is directory\n * @property {() => boolean} isBlockDevice is block device\n * @property {() => boolean} isCharacterDevice is character device\n * @property {() => boolean} isSymbolicLink is symbolic link\n * @property {() => boolean} isFIFO is FIFO\n * @property {() => boolean} isSocket is socket\n * @property {T} dev dev\n * @property {T} ino ino\n * @property {T} mode mode\n * @property {T} nlink nlink\n * @property {T} uid uid\n * @property {T} gid gid\n * @property {T} rdev rdev\n * @property {T} size size\n * @property {T} blksize blksize\n * @property {T} blocks blocks\n * @property {T} atimeMs atime ms\n * @property {T} mtimeMs mtime ms\n * @property {T} ctimeMs ctime ms\n * @property {T} birthtimeMs birthtime ms\n * @property {Date} atime atime\n * @property {Date} mtime mtime\n * @property {Date} ctime ctime\n * @property {Date} birthtime birthtime\n */\n\n/**\n * @typedef {IStatsBase<number>} IStats\n */\n\n/**\n * @typedef {IStatsBase<bigint> & { atimeNs: bigint, mtimeNs: bigint, ctimeNs: bigint, birthtimeNs: bigint }} IBigIntStats\n */\n\n/**\n * @template {string | Buffer} [T=string]\n * @typedef {object} Dirent\n * @property {() => boolean} isFile true when is file, otherwise false\n * @property {() => boolean} isDirectory true when is directory, otherwise false\n * @property {() => boolean} isBlockDevice true when is block device, otherwise false\n * @property {() => boolean} isCharacterDevice true when is character device, otherwise false\n * @property {() => boolean} isSymbolicLink true when is symbolic link, otherwise false\n * @property {() => boolean} isFIFO true when is FIFO, otherwise false\n * @property {() => boolean} isSocket true when is socket, otherwise false\n * @property {T} name name\n * @property {string} parentPath path\n * @property {string=} path path\n */\n\n/**\n * @typedef {object} StatOptions\n * @property {(boolean | undefined)=} bigint need bigint values\n */\n\n/**\n * @typedef {object} StatSyncOptions\n * @property {(boolean | undefined)=} bigint need bigint values\n * @property {(boolean | undefined)=} throwIfNoEntry throw if no entry\n */\n\n/**\n * @typedef {{\n * (path: PathOrFileDescriptor, options: ({ encoding?: null | undefined, flag?: string | undefined } & import(\"events\").Abortable) | undefined | null, callback: BufferCallback): void;\n * (path: PathOrFileDescriptor, options: ({ encoding: BufferEncoding, flag?: string | undefined } & import(\"events\").Abortable) | BufferEncoding, callback: StringCallback): void;\n * (path: PathOrFileDescriptor, options: (ObjectEncodingOptions & { flag?: string | undefined } & import(\"events\").Abortable) | BufferEncoding | undefined | null, callback: StringOrBufferCallback): void;\n * (path: PathOrFileDescriptor, callback: BufferCallback): void;\n * }} ReadFile\n */\n\n/**\n * @typedef {'buffer'| { encoding: 'buffer' }} BufferEncodingOption\n */\n\n/**\n * @typedef {{\n * (path: PathOrFileDescriptor, options?: { encoding?: null | undefined, flag?: string | undefined } | null): Buffer;\n * (path: PathOrFileDescriptor, options: { encoding: BufferEncoding, flag?: string | undefined } | BufferEncoding): string;\n * (path: PathOrFileDescriptor, options?: (ObjectEncodingOptions & { flag?: string | undefined }) | BufferEncoding | null): string | Buffer;\n * }} ReadFileSync\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options: { encoding: BufferEncoding | null, withFileTypes?: false | undefined, recursive?: boolean | undefined } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException | null, files?: string[]) => void): void;\n * (path: PathLike, options: { encoding: 'buffer', withFileTypes?: false | undefined, recursive?: boolean | undefined } | 'buffer', callback: (err: NodeJS.ErrnoException | null, files?: Buffer[]) => void): void;\n * (path: PathLike, options: (ObjectEncodingOptions & { withFileTypes?: false | undefined, recursive?: boolean | undefined }) | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException | null, files?: string[] | Buffer[]) => void): void;\n * (path: PathLike, callback: (err: NodeJS.ErrnoException | null, files?: string[]) => void): void;\n * (path: PathLike, options: ObjectEncodingOptions & { withFileTypes: true, recursive?: boolean | undefined }, callback: (err: NodeJS.ErrnoException | null, files?: Dirent<string>[]) => void): void;\n * (path: PathLike, options: { encoding: 'buffer', withFileTypes: true, recursive?: boolean | undefined }, callback: (err: NodeJS.ErrnoException | null, files: Dirent<Buffer>[]) => void): void;\n * }} Readdir\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options?: { encoding: BufferEncoding | null, withFileTypes?: false | undefined, recursive?: boolean | undefined; } | BufferEncoding | null): string[];\n * (path: PathLike, options: { encoding: 'buffer', withFileTypes?: false | undefined, recursive?: boolean | undefined } | 'buffer'): Buffer[];\n * (path: PathLike, options?: (ObjectEncodingOptions & { withFileTypes?: false | undefined, recursive?: boolean | undefined }) | BufferEncoding | null): string[] | Buffer[];\n * (path: PathLike, options: ObjectEncodingOptions & { withFileTypes: true, recursive?: boolean | undefined }): Dirent[];\n * (path: PathLike, options: { encoding: \"buffer\", withFileTypes: true, recursive?: boolean | undefined }): Dirent<Buffer>[];\n * }} ReaddirSync\n */\n\n/**\n * @typedef {(pathOrFileDescription: PathOrFileDescriptor, callback: ReadJsonCallback) => void} ReadJson\n */\n\n/**\n * @typedef {(pathOrFileDescription: PathOrFileDescriptor) => JsonObject} ReadJsonSync\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options: EncodingOption, callback: StringCallback): void;\n * (path: PathLike, options: BufferEncodingOption, callback: BufferCallback): void;\n * (path: PathLike, options: EncodingOption, callback: StringOrBufferCallback): void;\n * (path: PathLike, callback: StringCallback): void;\n * }} Readlink\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options?: EncodingOption): string;\n * (path: PathLike, options: BufferEncodingOption): Buffer;\n * (path: PathLike, options?: EncodingOption): string | Buffer;\n * }} ReadlinkSync\n */\n\n/**\n * @typedef {{\n * (path: PathLike, callback: StatsCallback): void;\n * (path: PathLike, options: (StatOptions & { bigint?: false | undefined }) | undefined, callback: StatsCallback): void;\n * (path: PathLike, options: StatOptions & { bigint: true }, callback: BigIntStatsCallback): void;\n * (path: PathLike, options: StatOptions | undefined, callback: StatsOrBigIntStatsCallback): void;\n * }} LStat\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options?: undefined): IStats;\n * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined, throwIfNoEntry: false }): IStats | undefined;\n * (path: PathLike, options: StatSyncOptions & { bigint: true, throwIfNoEntry: false }): IBigIntStats | undefined;\n * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined }): IStats;\n * (path: PathLike, options: StatSyncOptions & { bigint: true }): IBigIntStats;\n * (path: PathLike,  options: StatSyncOptions & { bigint: boolean, throwIfNoEntry?: false | undefined }): IStats | IBigIntStats;\n * (path: PathLike,  options?: StatSyncOptions): IStats | IBigIntStats | undefined;\n * }} LStatSync\n */\n\n/**\n * @typedef {{\n * (path: PathLike, callback: StatsCallback): void;\n * (path: PathLike, options: (StatOptions & { bigint?: false | undefined }) | undefined, callback: StatsCallback): void;\n * (path: PathLike, options: StatOptions & { bigint: true }, callback: BigIntStatsCallback): void;\n * (path: PathLike, options: StatOptions | undefined, callback: StatsOrBigIntStatsCallback): void;\n * }} Stat\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options?: undefined): IStats;\n * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined, throwIfNoEntry: false }): IStats | undefined;\n * (path: PathLike, options: StatSyncOptions & { bigint: true, throwIfNoEntry: false }): IBigIntStats | undefined;\n * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined }): IStats;\n * (path: PathLike, options: StatSyncOptions & { bigint: true }): IBigIntStats;\n * (path: PathLike,  options: StatSyncOptions & { bigint: boolean, throwIfNoEntry?: false | undefined }): IStats | IBigIntStats;\n * (path: PathLike,  options?: StatSyncOptions): IStats | IBigIntStats | undefined;\n * }} StatSync\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options: EncodingOption, callback: StringCallback): void;\n * (path: PathLike, options: BufferEncodingOption, callback: BufferCallback): void;\n * (path: PathLike, options: EncodingOption, callback: StringOrBufferCallback): void;\n * (path: PathLike, callback: StringCallback): void;\n * }} RealPath\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options?: EncodingOption): string;\n * (path: PathLike, options: BufferEncodingOption): Buffer;\n * (path: PathLike, options?: EncodingOption): string | Buffer;\n * }} RealPathSync\n */\n\n/**\n * @typedef {object} FileSystem\n * @property {ReadFile} readFile read file method\n * @property {Readdir} readdir readdir method\n * @property {ReadJson=} readJson read json method\n * @property {Readlink} readlink read link method\n * @property {LStat=} lstat lstat method\n * @property {Stat} stat stat method\n * @property {RealPath=} realpath realpath method\n */\n\n/**\n * @typedef {object} SyncFileSystem\n * @property {ReadFileSync} readFileSync read file sync method\n * @property {ReaddirSync} readdirSync read dir sync method\n * @property {ReadJsonSync=} readJsonSync read json sync method\n * @property {ReadlinkSync} readlinkSync read link sync method\n * @property {LStatSync=} lstatSync lstat sync method\n * @property {StatSync} statSync stat sync method\n * @property {RealPathSync=} realpathSync real path sync method\n */\n\n/**\n * @typedef {object} ParsedIdentifier\n * @property {string} request request\n * @property {string} query query\n * @property {string} fragment fragment\n * @property {boolean} directory is directory\n * @property {boolean} module is module\n * @property {boolean} file is file\n * @property {boolean} internal is internal\n */\n\n/** @typedef {string | number | boolean | null} JsonPrimitive */\n/** @typedef {JsonValue[]} JsonArray */\n/** @typedef {JsonPrimitive | JsonObject | JsonArray} JsonValue */\n/** @typedef {{ [Key in string]?: JsonValue | undefined }} JsonObject */\n\n// eslint-disable-next-line jsdoc/require-property\n/** @typedef {object} Context */\n\n/**\n * @typedef {object} BaseResolveRequest\n * @property {string | false} path path\n * @property {Context=} context content\n * @property {string=} descriptionFilePath description file path\n * @property {string=} descriptionFileRoot description file root\n * @property {JsonObject=} descriptionFileData description file data\n * @property {string=} relativePath relative path\n * @property {boolean=} ignoreSymlinks true when need to ignore symlinks, otherwise false\n * @property {boolean=} fullySpecified true when full specified, otherwise false\n * @property {string=} __innerRequest inner request for internal usage\n * @property {string=} __innerRequest_request inner request for internal usage\n * @property {string=} __innerRequest_relativePath inner relative path for internal usage\n */\n\n/** @typedef {BaseResolveRequest & Partial<ParsedIdentifier>} ResolveRequest */\n\n/**\n * String with special formatting\n * @typedef {string} StackEntry\n */\n\n/**\n * @template T\n * @typedef {{ add: (item: T) => void }} WriteOnlySet\n */\n\n/** @typedef {(request: ResolveRequest) => void} ResolveContextYield */\n\n/**\n * Resolve context\n * @typedef {object} ResolveContext\n * @property {WriteOnlySet<string>=} contextDependencies directories that was found on file system\n * @property {WriteOnlySet<string>=} fileDependencies files that was found on file system\n * @property {WriteOnlySet<string>=} missingDependencies dependencies that was not found on file system\n * @property {Set<StackEntry>=} stack set of hooks' calls. For instance, `resolve → parsedResolve → describedResolve`,\n * @property {((str: string) => void)=} log log function\n * @property {ResolveContextYield=} yield yield result, if provided plugins can return several results\n */\n\n/** @typedef {AsyncSeriesBailHook<[ResolveRequest, ResolveContext], ResolveRequest | null>} ResolveStepHook */\n\n/**\n * @typedef {object} KnownHooks\n * @property {SyncHook<[ResolveStepHook, ResolveRequest], void>} resolveStep resolve step hook\n * @property {SyncHook<[ResolveRequest, Error]>} noResolve no resolve hook\n * @property {ResolveStepHook} resolve resolve hook\n * @property {AsyncSeriesHook<[ResolveRequest, ResolveContext]>} result result hook\n */\n\n/**\n * @typedef {{[key: string]: ResolveStepHook}} EnsuredHooks\n */\n\n/**\n * @param {string} str input string\n * @returns {string} in camel case\n */\nfunction toCamelCase(str) {\n  return str.replace(/-([a-z])/g, str => str.slice(1).toUpperCase());\n}\nclass Resolver {\n  /**\n   * @param {ResolveStepHook} hook hook\n   * @param {ResolveRequest} request request\n   * @returns {StackEntry} stack entry\n   */\n  static createStackEntry(hook, request) {\n    return `${hook.name}: (${request.path}) ${request.request || \"\"}${request.query || \"\"}${request.fragment || \"\"}${request.directory ? \" directory\" : \"\"}${request.module ? \" module\" : \"\"}`;\n  }\n\n  /**\n   * @param {FileSystem} fileSystem a filesystem\n   * @param {ResolveOptions} options options\n   */\n  constructor(fileSystem, options) {\n    this.fileSystem = fileSystem;\n    this.options = options;\n    /** @type {KnownHooks} */\n    this.hooks = {\n      resolveStep: new SyncHook([\"hook\", \"request\"], \"resolveStep\"),\n      noResolve: new SyncHook([\"request\", \"error\"], \"noResolve\"),\n      resolve: new AsyncSeriesBailHook([\"request\", \"resolveContext\"], \"resolve\"),\n      result: new AsyncSeriesHook([\"result\", \"resolveContext\"], \"result\")\n    };\n  }\n\n  /**\n   * @param {string | ResolveStepHook} name hook name or hook itself\n   * @returns {ResolveStepHook} the hook\n   */\n  ensureHook(name) {\n    if (typeof name !== \"string\") {\n      return name;\n    }\n    name = toCamelCase(name);\n    if (name.startsWith(\"before\")) {\n      return /** @type {ResolveStepHook} */this.ensureHook(name[6].toLowerCase() + name.slice(7)).withOptions({\n        stage: -10\n      });\n    }\n    if (name.startsWith(\"after\")) {\n      return /** @type {ResolveStepHook} */this.ensureHook(name[5].toLowerCase() + name.slice(6)).withOptions({\n        stage: 10\n      });\n    }\n    /** @type {ResolveStepHook} */\n    const hook = /** @type {KnownHooks & EnsuredHooks} */this.hooks[name];\n    if (!hook) {\n      /** @type {KnownHooks & EnsuredHooks} */\n      this.hooks[name] = new AsyncSeriesBailHook([\"request\", \"resolveContext\"], name);\n      return /** @type {KnownHooks & EnsuredHooks} */this.hooks[name];\n    }\n    return hook;\n  }\n\n  /**\n   * @param {string | ResolveStepHook} name hook name or hook itself\n   * @returns {ResolveStepHook} the hook\n   */\n  getHook(name) {\n    if (typeof name !== \"string\") {\n      return name;\n    }\n    name = toCamelCase(name);\n    if (name.startsWith(\"before\")) {\n      return /** @type {ResolveStepHook} */this.getHook(name[6].toLowerCase() + name.slice(7)).withOptions({\n        stage: -10\n      });\n    }\n    if (name.startsWith(\"after\")) {\n      return /** @type {ResolveStepHook} */this.getHook(name[5].toLowerCase() + name.slice(6)).withOptions({\n        stage: 10\n      });\n    }\n    /** @type {ResolveStepHook} */\n    const hook = /** @type {KnownHooks & EnsuredHooks} */this.hooks[name];\n    if (!hook) {\n      throw new Error(`Hook ${name} doesn't exist`);\n    }\n    return hook;\n  }\n\n  /**\n   * @param {object} context context information object\n   * @param {string} path context path\n   * @param {string} request request string\n   * @returns {string | false} result\n   */\n  resolveSync(context, path, request) {\n    /** @type {Error | null | undefined} */\n    let err;\n    /** @type {string | false | undefined} */\n    let result;\n    let sync = false;\n    this.resolve(context, path, request, {}, (_err, r) => {\n      err = _err;\n      result = r;\n      sync = true;\n    });\n    if (!sync) {\n      throw new Error(\"Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!\");\n    }\n    if (err) throw err;\n    if (result === undefined) throw new Error(\"No result\");\n    return result;\n  }\n\n  /**\n   * @param {object} context context information object\n   * @param {string} path context path\n   * @param {string} request request string\n   * @param {ResolveContext} resolveContext resolve context\n   * @param {ResolveCallback} callback callback function\n   * @returns {void}\n   */\n  resolve(context, path, request, resolveContext, callback) {\n    if (!context || typeof context !== \"object\") {\n      return callback(new Error(\"context argument is not an object\"));\n    }\n    if (typeof path !== \"string\") {\n      return callback(new Error(\"path argument is not a string\"));\n    }\n    if (typeof request !== \"string\") {\n      return callback(new Error(\"request argument is not a string\"));\n    }\n    if (!resolveContext) {\n      return callback(new Error(\"resolveContext argument is not set\"));\n    }\n\n    /** @type {ResolveRequest} */\n    const obj = {\n      context,\n      path,\n      request\n    };\n\n    /** @type {ResolveContextYield | undefined} */\n    let yield_;\n    let yieldCalled = false;\n    /** @type {ResolveContextYield | undefined} */\n    let finishYield;\n    if (typeof resolveContext.yield === \"function\") {\n      const old = resolveContext.yield;\n      /**\n       * @param {ResolveRequest} obj object\n       */\n      yield_ = obj => {\n        old(obj);\n        yieldCalled = true;\n      };\n      /**\n       * @param {ResolveRequest} result result\n       * @returns {void}\n       */\n      finishYield = result => {\n        if (result) {\n          /** @type {ResolveContextYield} */yield_(result);\n        }\n        callback(null);\n      };\n    }\n    const message = `resolve '${request}' in '${path}'`;\n\n    /**\n     * @param {ResolveRequest} result result\n     * @returns {void}\n     */\n    const finishResolved = result => callback(null, result.path === false ? false : `${result.path.replace(/#/g, \"\\0#\")}${result.query ? result.query.replace(/#/g, \"\\0#\") : \"\"}${result.fragment || \"\"}`, result);\n\n    /**\n     * @param {string[]} log logs\n     * @returns {void}\n     */\n    const finishWithoutResolve = log => {\n      /**\n       * @type {ErrorWithDetail}\n       */\n      const error = new Error(`Can't ${message}`);\n      error.details = log.join(\"\\n\");\n      this.hooks.noResolve.call(obj, error);\n      return callback(error);\n    };\n    if (resolveContext.log) {\n      // We need log anyway to capture it in case of an error\n      const parentLog = resolveContext.log;\n      /** @type {string[]} */\n      const log = [];\n      return this.doResolve(this.hooks.resolve, obj, message, {\n        log: msg => {\n          parentLog(msg);\n          log.push(msg);\n        },\n        yield: yield_,\n        fileDependencies: resolveContext.fileDependencies,\n        contextDependencies: resolveContext.contextDependencies,\n        missingDependencies: resolveContext.missingDependencies,\n        stack: resolveContext.stack\n      }, (err, result) => {\n        if (err) return callback(err);\n        if (yieldCalled || result && yield_) {\n          return /** @type {ResolveContextYield} */finishYield(/** @type {ResolveRequest} */result);\n        }\n        if (result) return finishResolved(result);\n        return finishWithoutResolve(log);\n      });\n    }\n    // Try to resolve assuming there is no error\n    // We don't log stuff in this case\n    return this.doResolve(this.hooks.resolve, obj, message, {\n      log: undefined,\n      yield: yield_,\n      fileDependencies: resolveContext.fileDependencies,\n      contextDependencies: resolveContext.contextDependencies,\n      missingDependencies: resolveContext.missingDependencies,\n      stack: resolveContext.stack\n    }, (err, result) => {\n      if (err) return callback(err);\n      if (yieldCalled || result && yield_) {\n        return /** @type {ResolveContextYield} */finishYield(/** @type {ResolveRequest} */result);\n      }\n      if (result) return finishResolved(result);\n\n      // log is missing for the error details\n      // so we redo the resolving for the log info\n      // this is more expensive to the success case\n      // is assumed by default\n      /** @type {string[]} */\n      const log = [];\n      return this.doResolve(this.hooks.resolve, obj, message, {\n        log: msg => log.push(msg),\n        yield: yield_,\n        stack: resolveContext.stack\n      }, (err, result) => {\n        if (err) return callback(err);\n\n        // In a case that there is a race condition and yield will be called\n        if (yieldCalled || result && yield_) {\n          return /** @type {ResolveContextYield} */finishYield(/** @type {ResolveRequest} */result);\n        }\n        return finishWithoutResolve(log);\n      });\n    });\n  }\n\n  /**\n   * @param {ResolveStepHook} hook hook\n   * @param {ResolveRequest} request request\n   * @param {null|string} message string\n   * @param {ResolveContext} resolveContext resolver context\n   * @param {(err?: null|Error, result?: ResolveRequest) => void} callback callback\n   * @returns {void}\n   */\n  doResolve(hook, request, message, resolveContext, callback) {\n    const stackEntry = Resolver.createStackEntry(hook, request);\n\n    /** @type {Set<string> | undefined} */\n    let newStack;\n    if (resolveContext.stack) {\n      newStack = new Set(resolveContext.stack);\n      if (resolveContext.stack.has(stackEntry)) {\n        /**\n         * Prevent recursion\n         * @type {Error & {recursion?: boolean}}\n         */\n        const recursionError = new Error(`Recursion in resolving\\nStack:\\n  ${[...newStack].join(\"\\n  \")}`);\n        recursionError.recursion = true;\n        if (resolveContext.log) {\n          resolveContext.log(\"abort resolving because of recursion\");\n        }\n        return callback(recursionError);\n      }\n      newStack.add(stackEntry);\n    } else {\n      // creating a set with new Set([item])\n      // allocates a new array that has to be garbage collected\n      // this is an EXTREMELY hot path, so let's avoid it\n      newStack = new Set();\n      newStack.add(stackEntry);\n    }\n    this.hooks.resolveStep.call(hook, request);\n    if (hook.isUsed()) {\n      const innerContext = createInnerContext({\n        log: resolveContext.log,\n        yield: resolveContext.yield,\n        fileDependencies: resolveContext.fileDependencies,\n        contextDependencies: resolveContext.contextDependencies,\n        missingDependencies: resolveContext.missingDependencies,\n        stack: newStack\n      }, message);\n      return hook.callAsync(request, innerContext, (err, result) => {\n        if (err) return callback(err);\n        if (result) return callback(null, result);\n        callback();\n      });\n    }\n    callback();\n  }\n\n  /**\n   * @param {string} identifier identifier\n   * @returns {ParsedIdentifier} parsed identifier\n   */\n  parse(identifier) {\n    const part = {\n      request: \"\",\n      query: \"\",\n      fragment: \"\",\n      module: false,\n      directory: false,\n      file: false,\n      internal: false\n    };\n    const parsedIdentifier = parseIdentifier(identifier);\n    if (!parsedIdentifier) return part;\n    [part.request, part.query, part.fragment] = parsedIdentifier;\n    if (part.request.length > 0) {\n      part.internal = this.isPrivate(identifier);\n      part.module = this.isModule(part.request);\n      part.directory = this.isDirectory(part.request);\n      if (part.directory) {\n        part.request = part.request.slice(0, -1);\n      }\n    }\n    return part;\n  }\n\n  /**\n   * @param {string} path path\n   * @returns {boolean} true, if the path is a module\n   */\n  isModule(path) {\n    return getType(path) === PathType.Normal;\n  }\n\n  /**\n   * @param {string} path path\n   * @returns {boolean} true, if the path is private\n   */\n  isPrivate(path) {\n    return getType(path) === PathType.Internal;\n  }\n\n  /**\n   * @param {string} path a path\n   * @returns {boolean} true, if the path is a directory path\n   */\n  isDirectory(path) {\n    return path.endsWith(\"/\");\n  }\n\n  /**\n   * @param {string} path path\n   * @param {string} request request\n   * @returns {string} joined path\n   */\n  join(path, request) {\n    return join(path, request);\n  }\n\n  /**\n   * @param {string} path path\n   * @returns {string} normalized path\n   */\n  normalize(path) {\n    return normalize(path);\n  }\n}\nmodule.exports = Resolver;","map":{"version":3,"names":["AsyncSeriesBailHook","AsyncSeriesHook","SyncHook","require","createInnerContext","parseIdentifier","PathType","cachedJoin","join","getType","normalize","toCamelCase","str","replace","slice","toUpperCase","Resolver","createStackEntry","hook","request","name","path","query","fragment","directory","module","constructor","fileSystem","options","hooks","resolveStep","noResolve","resolve","result","ensureHook","startsWith","toLowerCase","withOptions","stage","getHook","Error","resolveSync","context","err","sync","_err","r","undefined","resolveContext","callback","obj","yield_","yieldCalled","finishYield","yield","old","message","finishResolved","finishWithoutResolve","log","error","details","call","parentLog","doResolve","msg","push","fileDependencies","contextDependencies","missingDependencies","stack","stackEntry","newStack","Set","has","recursionError","recursion","add","isUsed","innerContext","callAsync","parse","identifier","part","file","internal","parsedIdentifier","length","isPrivate","isModule","isDirectory","Normal","Internal","endsWith","exports"],"sources":["C:/Users/dah03/calendar/mycalendar/node_modules/enhanced-resolve/lib/Resolver.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { AsyncSeriesBailHook, AsyncSeriesHook, SyncHook } = require(\"tapable\");\nconst createInnerContext = require(\"./createInnerContext\");\nconst { parseIdentifier } = require(\"./util/identifier\");\nconst {\n\tPathType,\n\tcachedJoin: join,\n\tgetType,\n\tnormalize,\n} = require(\"./util/path\");\n\n/** @typedef {import(\"./ResolverFactory\").ResolveOptions} ResolveOptions */\n\n/** @typedef {Error & { details?: string }} ErrorWithDetail */\n\n/** @typedef {(err: ErrorWithDetail | null, res?: string | false, req?: ResolveRequest) => void} ResolveCallback */\n\n/**\n * @typedef {object} PossibleFileSystemError\n * @property {string=} code code\n * @property {number=} errno number\n * @property {string=} path path\n * @property {string=} syscall syscall\n */\n\n/**\n * @template T\n * @callback FileSystemCallback\n * @param {PossibleFileSystemError & Error | null} err\n * @param {T=} result\n */\n\n/**\n * @typedef {string | Buffer | URL} PathLike\n */\n\n/**\n * @typedef {PathLike | number} PathOrFileDescriptor\n */\n\n/**\n * @typedef {object} ObjectEncodingOptions\n * @property {BufferEncoding | null | undefined=} encoding encoding\n */\n\n/**\n * @typedef {ObjectEncodingOptions | BufferEncoding | undefined | null} EncodingOption\n */\n\n/** @typedef {(err: NodeJS.ErrnoException | null, result?: string) => void} StringCallback */\n/** @typedef {(err: NodeJS.ErrnoException | null, result?: Buffer) => void} BufferCallback */\n/** @typedef {(err: NodeJS.ErrnoException | null, result?: (string | Buffer)) => void} StringOrBufferCallback */\n/** @typedef {(err: NodeJS.ErrnoException | null, result?: IStats) => void} StatsCallback */\n/** @typedef {(err: NodeJS.ErrnoException | null, result?: IBigIntStats) => void} BigIntStatsCallback */\n/** @typedef {(err: NodeJS.ErrnoException | null, result?: (IStats | IBigIntStats)) => void} StatsOrBigIntStatsCallback */\n/** @typedef {(err: NodeJS.ErrnoException | Error | null, result?: JsonObject) => void} ReadJsonCallback */\n\n/**\n * @template T\n * @typedef {object} IStatsBase\n * @property {() => boolean} isFile is file\n * @property {() => boolean} isDirectory is directory\n * @property {() => boolean} isBlockDevice is block device\n * @property {() => boolean} isCharacterDevice is character device\n * @property {() => boolean} isSymbolicLink is symbolic link\n * @property {() => boolean} isFIFO is FIFO\n * @property {() => boolean} isSocket is socket\n * @property {T} dev dev\n * @property {T} ino ino\n * @property {T} mode mode\n * @property {T} nlink nlink\n * @property {T} uid uid\n * @property {T} gid gid\n * @property {T} rdev rdev\n * @property {T} size size\n * @property {T} blksize blksize\n * @property {T} blocks blocks\n * @property {T} atimeMs atime ms\n * @property {T} mtimeMs mtime ms\n * @property {T} ctimeMs ctime ms\n * @property {T} birthtimeMs birthtime ms\n * @property {Date} atime atime\n * @property {Date} mtime mtime\n * @property {Date} ctime ctime\n * @property {Date} birthtime birthtime\n */\n\n/**\n * @typedef {IStatsBase<number>} IStats\n */\n\n/**\n * @typedef {IStatsBase<bigint> & { atimeNs: bigint, mtimeNs: bigint, ctimeNs: bigint, birthtimeNs: bigint }} IBigIntStats\n */\n\n/**\n * @template {string | Buffer} [T=string]\n * @typedef {object} Dirent\n * @property {() => boolean} isFile true when is file, otherwise false\n * @property {() => boolean} isDirectory true when is directory, otherwise false\n * @property {() => boolean} isBlockDevice true when is block device, otherwise false\n * @property {() => boolean} isCharacterDevice true when is character device, otherwise false\n * @property {() => boolean} isSymbolicLink true when is symbolic link, otherwise false\n * @property {() => boolean} isFIFO true when is FIFO, otherwise false\n * @property {() => boolean} isSocket true when is socket, otherwise false\n * @property {T} name name\n * @property {string} parentPath path\n * @property {string=} path path\n */\n\n/**\n * @typedef {object} StatOptions\n * @property {(boolean | undefined)=} bigint need bigint values\n */\n\n/**\n * @typedef {object} StatSyncOptions\n * @property {(boolean | undefined)=} bigint need bigint values\n * @property {(boolean | undefined)=} throwIfNoEntry throw if no entry\n */\n\n/**\n * @typedef {{\n * (path: PathOrFileDescriptor, options: ({ encoding?: null | undefined, flag?: string | undefined } & import(\"events\").Abortable) | undefined | null, callback: BufferCallback): void;\n * (path: PathOrFileDescriptor, options: ({ encoding: BufferEncoding, flag?: string | undefined } & import(\"events\").Abortable) | BufferEncoding, callback: StringCallback): void;\n * (path: PathOrFileDescriptor, options: (ObjectEncodingOptions & { flag?: string | undefined } & import(\"events\").Abortable) | BufferEncoding | undefined | null, callback: StringOrBufferCallback): void;\n * (path: PathOrFileDescriptor, callback: BufferCallback): void;\n * }} ReadFile\n */\n\n/**\n * @typedef {'buffer'| { encoding: 'buffer' }} BufferEncodingOption\n */\n\n/**\n * @typedef {{\n * (path: PathOrFileDescriptor, options?: { encoding?: null | undefined, flag?: string | undefined } | null): Buffer;\n * (path: PathOrFileDescriptor, options: { encoding: BufferEncoding, flag?: string | undefined } | BufferEncoding): string;\n * (path: PathOrFileDescriptor, options?: (ObjectEncodingOptions & { flag?: string | undefined }) | BufferEncoding | null): string | Buffer;\n * }} ReadFileSync\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options: { encoding: BufferEncoding | null, withFileTypes?: false | undefined, recursive?: boolean | undefined } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException | null, files?: string[]) => void): void;\n * (path: PathLike, options: { encoding: 'buffer', withFileTypes?: false | undefined, recursive?: boolean | undefined } | 'buffer', callback: (err: NodeJS.ErrnoException | null, files?: Buffer[]) => void): void;\n * (path: PathLike, options: (ObjectEncodingOptions & { withFileTypes?: false | undefined, recursive?: boolean | undefined }) | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException | null, files?: string[] | Buffer[]) => void): void;\n * (path: PathLike, callback: (err: NodeJS.ErrnoException | null, files?: string[]) => void): void;\n * (path: PathLike, options: ObjectEncodingOptions & { withFileTypes: true, recursive?: boolean | undefined }, callback: (err: NodeJS.ErrnoException | null, files?: Dirent<string>[]) => void): void;\n * (path: PathLike, options: { encoding: 'buffer', withFileTypes: true, recursive?: boolean | undefined }, callback: (err: NodeJS.ErrnoException | null, files: Dirent<Buffer>[]) => void): void;\n * }} Readdir\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options?: { encoding: BufferEncoding | null, withFileTypes?: false | undefined, recursive?: boolean | undefined; } | BufferEncoding | null): string[];\n * (path: PathLike, options: { encoding: 'buffer', withFileTypes?: false | undefined, recursive?: boolean | undefined } | 'buffer'): Buffer[];\n * (path: PathLike, options?: (ObjectEncodingOptions & { withFileTypes?: false | undefined, recursive?: boolean | undefined }) | BufferEncoding | null): string[] | Buffer[];\n * (path: PathLike, options: ObjectEncodingOptions & { withFileTypes: true, recursive?: boolean | undefined }): Dirent[];\n * (path: PathLike, options: { encoding: \"buffer\", withFileTypes: true, recursive?: boolean | undefined }): Dirent<Buffer>[];\n * }} ReaddirSync\n */\n\n/**\n * @typedef {(pathOrFileDescription: PathOrFileDescriptor, callback: ReadJsonCallback) => void} ReadJson\n */\n\n/**\n * @typedef {(pathOrFileDescription: PathOrFileDescriptor) => JsonObject} ReadJsonSync\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options: EncodingOption, callback: StringCallback): void;\n * (path: PathLike, options: BufferEncodingOption, callback: BufferCallback): void;\n * (path: PathLike, options: EncodingOption, callback: StringOrBufferCallback): void;\n * (path: PathLike, callback: StringCallback): void;\n * }} Readlink\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options?: EncodingOption): string;\n * (path: PathLike, options: BufferEncodingOption): Buffer;\n * (path: PathLike, options?: EncodingOption): string | Buffer;\n * }} ReadlinkSync\n */\n\n/**\n * @typedef {{\n * (path: PathLike, callback: StatsCallback): void;\n * (path: PathLike, options: (StatOptions & { bigint?: false | undefined }) | undefined, callback: StatsCallback): void;\n * (path: PathLike, options: StatOptions & { bigint: true }, callback: BigIntStatsCallback): void;\n * (path: PathLike, options: StatOptions | undefined, callback: StatsOrBigIntStatsCallback): void;\n * }} LStat\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options?: undefined): IStats;\n * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined, throwIfNoEntry: false }): IStats | undefined;\n * (path: PathLike, options: StatSyncOptions & { bigint: true, throwIfNoEntry: false }): IBigIntStats | undefined;\n * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined }): IStats;\n * (path: PathLike, options: StatSyncOptions & { bigint: true }): IBigIntStats;\n * (path: PathLike,  options: StatSyncOptions & { bigint: boolean, throwIfNoEntry?: false | undefined }): IStats | IBigIntStats;\n * (path: PathLike,  options?: StatSyncOptions): IStats | IBigIntStats | undefined;\n * }} LStatSync\n */\n\n/**\n * @typedef {{\n * (path: PathLike, callback: StatsCallback): void;\n * (path: PathLike, options: (StatOptions & { bigint?: false | undefined }) | undefined, callback: StatsCallback): void;\n * (path: PathLike, options: StatOptions & { bigint: true }, callback: BigIntStatsCallback): void;\n * (path: PathLike, options: StatOptions | undefined, callback: StatsOrBigIntStatsCallback): void;\n * }} Stat\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options?: undefined): IStats;\n * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined, throwIfNoEntry: false }): IStats | undefined;\n * (path: PathLike, options: StatSyncOptions & { bigint: true, throwIfNoEntry: false }): IBigIntStats | undefined;\n * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined }): IStats;\n * (path: PathLike, options: StatSyncOptions & { bigint: true }): IBigIntStats;\n * (path: PathLike,  options: StatSyncOptions & { bigint: boolean, throwIfNoEntry?: false | undefined }): IStats | IBigIntStats;\n * (path: PathLike,  options?: StatSyncOptions): IStats | IBigIntStats | undefined;\n * }} StatSync\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options: EncodingOption, callback: StringCallback): void;\n * (path: PathLike, options: BufferEncodingOption, callback: BufferCallback): void;\n * (path: PathLike, options: EncodingOption, callback: StringOrBufferCallback): void;\n * (path: PathLike, callback: StringCallback): void;\n * }} RealPath\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options?: EncodingOption): string;\n * (path: PathLike, options: BufferEncodingOption): Buffer;\n * (path: PathLike, options?: EncodingOption): string | Buffer;\n * }} RealPathSync\n */\n\n/**\n * @typedef {object} FileSystem\n * @property {ReadFile} readFile read file method\n * @property {Readdir} readdir readdir method\n * @property {ReadJson=} readJson read json method\n * @property {Readlink} readlink read link method\n * @property {LStat=} lstat lstat method\n * @property {Stat} stat stat method\n * @property {RealPath=} realpath realpath method\n */\n\n/**\n * @typedef {object} SyncFileSystem\n * @property {ReadFileSync} readFileSync read file sync method\n * @property {ReaddirSync} readdirSync read dir sync method\n * @property {ReadJsonSync=} readJsonSync read json sync method\n * @property {ReadlinkSync} readlinkSync read link sync method\n * @property {LStatSync=} lstatSync lstat sync method\n * @property {StatSync} statSync stat sync method\n * @property {RealPathSync=} realpathSync real path sync method\n */\n\n/**\n * @typedef {object} ParsedIdentifier\n * @property {string} request request\n * @property {string} query query\n * @property {string} fragment fragment\n * @property {boolean} directory is directory\n * @property {boolean} module is module\n * @property {boolean} file is file\n * @property {boolean} internal is internal\n */\n\n/** @typedef {string | number | boolean | null} JsonPrimitive */\n/** @typedef {JsonValue[]} JsonArray */\n/** @typedef {JsonPrimitive | JsonObject | JsonArray} JsonValue */\n/** @typedef {{ [Key in string]?: JsonValue | undefined }} JsonObject */\n\n// eslint-disable-next-line jsdoc/require-property\n/** @typedef {object} Context */\n\n/**\n * @typedef {object} BaseResolveRequest\n * @property {string | false} path path\n * @property {Context=} context content\n * @property {string=} descriptionFilePath description file path\n * @property {string=} descriptionFileRoot description file root\n * @property {JsonObject=} descriptionFileData description file data\n * @property {string=} relativePath relative path\n * @property {boolean=} ignoreSymlinks true when need to ignore symlinks, otherwise false\n * @property {boolean=} fullySpecified true when full specified, otherwise false\n * @property {string=} __innerRequest inner request for internal usage\n * @property {string=} __innerRequest_request inner request for internal usage\n * @property {string=} __innerRequest_relativePath inner relative path for internal usage\n */\n\n/** @typedef {BaseResolveRequest & Partial<ParsedIdentifier>} ResolveRequest */\n\n/**\n * String with special formatting\n * @typedef {string} StackEntry\n */\n\n/**\n * @template T\n * @typedef {{ add: (item: T) => void }} WriteOnlySet\n */\n\n/** @typedef {(request: ResolveRequest) => void} ResolveContextYield */\n\n/**\n * Resolve context\n * @typedef {object} ResolveContext\n * @property {WriteOnlySet<string>=} contextDependencies directories that was found on file system\n * @property {WriteOnlySet<string>=} fileDependencies files that was found on file system\n * @property {WriteOnlySet<string>=} missingDependencies dependencies that was not found on file system\n * @property {Set<StackEntry>=} stack set of hooks' calls. For instance, `resolve → parsedResolve → describedResolve`,\n * @property {((str: string) => void)=} log log function\n * @property {ResolveContextYield=} yield yield result, if provided plugins can return several results\n */\n\n/** @typedef {AsyncSeriesBailHook<[ResolveRequest, ResolveContext], ResolveRequest | null>} ResolveStepHook */\n\n/**\n * @typedef {object} KnownHooks\n * @property {SyncHook<[ResolveStepHook, ResolveRequest], void>} resolveStep resolve step hook\n * @property {SyncHook<[ResolveRequest, Error]>} noResolve no resolve hook\n * @property {ResolveStepHook} resolve resolve hook\n * @property {AsyncSeriesHook<[ResolveRequest, ResolveContext]>} result result hook\n */\n\n/**\n * @typedef {{[key: string]: ResolveStepHook}} EnsuredHooks\n */\n\n/**\n * @param {string} str input string\n * @returns {string} in camel case\n */\nfunction toCamelCase(str) {\n\treturn str.replace(/-([a-z])/g, (str) => str.slice(1).toUpperCase());\n}\n\nclass Resolver {\n\t/**\n\t * @param {ResolveStepHook} hook hook\n\t * @param {ResolveRequest} request request\n\t * @returns {StackEntry} stack entry\n\t */\n\tstatic createStackEntry(hook, request) {\n\t\treturn `${hook.name}: (${request.path}) ${request.request || \"\"}${\n\t\t\trequest.query || \"\"\n\t\t}${request.fragment || \"\"}${request.directory ? \" directory\" : \"\"}${\n\t\t\trequest.module ? \" module\" : \"\"\n\t\t}`;\n\t}\n\n\t/**\n\t * @param {FileSystem} fileSystem a filesystem\n\t * @param {ResolveOptions} options options\n\t */\n\tconstructor(fileSystem, options) {\n\t\tthis.fileSystem = fileSystem;\n\t\tthis.options = options;\n\t\t/** @type {KnownHooks} */\n\t\tthis.hooks = {\n\t\t\tresolveStep: new SyncHook([\"hook\", \"request\"], \"resolveStep\"),\n\t\t\tnoResolve: new SyncHook([\"request\", \"error\"], \"noResolve\"),\n\t\t\tresolve: new AsyncSeriesBailHook(\n\t\t\t\t[\"request\", \"resolveContext\"],\n\t\t\t\t\"resolve\",\n\t\t\t),\n\t\t\tresult: new AsyncSeriesHook([\"result\", \"resolveContext\"], \"result\"),\n\t\t};\n\t}\n\n\t/**\n\t * @param {string | ResolveStepHook} name hook name or hook itself\n\t * @returns {ResolveStepHook} the hook\n\t */\n\tensureHook(name) {\n\t\tif (typeof name !== \"string\") {\n\t\t\treturn name;\n\t\t}\n\t\tname = toCamelCase(name);\n\t\tif (name.startsWith(\"before\")) {\n\t\t\treturn /** @type {ResolveStepHook} */ (\n\t\t\t\tthis.ensureHook(name[6].toLowerCase() + name.slice(7)).withOptions({\n\t\t\t\t\tstage: -10,\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\tif (name.startsWith(\"after\")) {\n\t\t\treturn /** @type {ResolveStepHook} */ (\n\t\t\t\tthis.ensureHook(name[5].toLowerCase() + name.slice(6)).withOptions({\n\t\t\t\t\tstage: 10,\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\t/** @type {ResolveStepHook} */\n\t\tconst hook = /** @type {KnownHooks & EnsuredHooks} */ (this.hooks)[name];\n\t\tif (!hook) {\n\t\t\t/** @type {KnownHooks & EnsuredHooks} */\n\t\t\t(this.hooks)[name] = new AsyncSeriesBailHook(\n\t\t\t\t[\"request\", \"resolveContext\"],\n\t\t\t\tname,\n\t\t\t);\n\n\t\t\treturn /** @type {KnownHooks & EnsuredHooks} */ (this.hooks)[name];\n\t\t}\n\t\treturn hook;\n\t}\n\n\t/**\n\t * @param {string | ResolveStepHook} name hook name or hook itself\n\t * @returns {ResolveStepHook} the hook\n\t */\n\tgetHook(name) {\n\t\tif (typeof name !== \"string\") {\n\t\t\treturn name;\n\t\t}\n\t\tname = toCamelCase(name);\n\t\tif (name.startsWith(\"before\")) {\n\t\t\treturn /** @type {ResolveStepHook} */ (\n\t\t\t\tthis.getHook(name[6].toLowerCase() + name.slice(7)).withOptions({\n\t\t\t\t\tstage: -10,\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\tif (name.startsWith(\"after\")) {\n\t\t\treturn /** @type {ResolveStepHook} */ (\n\t\t\t\tthis.getHook(name[5].toLowerCase() + name.slice(6)).withOptions({\n\t\t\t\t\tstage: 10,\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\t/** @type {ResolveStepHook} */\n\t\tconst hook = /** @type {KnownHooks & EnsuredHooks} */ (this.hooks)[name];\n\t\tif (!hook) {\n\t\t\tthrow new Error(`Hook ${name} doesn't exist`);\n\t\t}\n\t\treturn hook;\n\t}\n\n\t/**\n\t * @param {object} context context information object\n\t * @param {string} path context path\n\t * @param {string} request request string\n\t * @returns {string | false} result\n\t */\n\tresolveSync(context, path, request) {\n\t\t/** @type {Error | null | undefined} */\n\t\tlet err;\n\t\t/** @type {string | false | undefined} */\n\t\tlet result;\n\t\tlet sync = false;\n\t\tthis.resolve(context, path, request, {}, (_err, r) => {\n\t\t\terr = _err;\n\t\t\tresult = r;\n\t\t\tsync = true;\n\t\t});\n\t\tif (!sync) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!\",\n\t\t\t);\n\t\t}\n\t\tif (err) throw err;\n\t\tif (result === undefined) throw new Error(\"No result\");\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {object} context context information object\n\t * @param {string} path context path\n\t * @param {string} request request string\n\t * @param {ResolveContext} resolveContext resolve context\n\t * @param {ResolveCallback} callback callback function\n\t * @returns {void}\n\t */\n\tresolve(context, path, request, resolveContext, callback) {\n\t\tif (!context || typeof context !== \"object\") {\n\t\t\treturn callback(new Error(\"context argument is not an object\"));\n\t\t}\n\t\tif (typeof path !== \"string\") {\n\t\t\treturn callback(new Error(\"path argument is not a string\"));\n\t\t}\n\t\tif (typeof request !== \"string\") {\n\t\t\treturn callback(new Error(\"request argument is not a string\"));\n\t\t}\n\t\tif (!resolveContext) {\n\t\t\treturn callback(new Error(\"resolveContext argument is not set\"));\n\t\t}\n\n\t\t/** @type {ResolveRequest} */\n\t\tconst obj = {\n\t\t\tcontext,\n\t\t\tpath,\n\t\t\trequest,\n\t\t};\n\n\t\t/** @type {ResolveContextYield | undefined} */\n\t\tlet yield_;\n\t\tlet yieldCalled = false;\n\t\t/** @type {ResolveContextYield | undefined} */\n\t\tlet finishYield;\n\t\tif (typeof resolveContext.yield === \"function\") {\n\t\t\tconst old = resolveContext.yield;\n\t\t\t/**\n\t\t\t * @param {ResolveRequest} obj object\n\t\t\t */\n\t\t\tyield_ = (obj) => {\n\t\t\t\told(obj);\n\t\t\t\tyieldCalled = true;\n\t\t\t};\n\t\t\t/**\n\t\t\t * @param {ResolveRequest} result result\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\tfinishYield = (result) => {\n\t\t\t\tif (result) {\n\t\t\t\t\t/** @type {ResolveContextYield} */ (yield_)(result);\n\t\t\t\t}\n\t\t\t\tcallback(null);\n\t\t\t};\n\t\t}\n\n\t\tconst message = `resolve '${request}' in '${path}'`;\n\n\t\t/**\n\t\t * @param {ResolveRequest} result result\n\t\t * @returns {void}\n\t\t */\n\t\tconst finishResolved = (result) =>\n\t\t\tcallback(\n\t\t\t\tnull,\n\t\t\t\tresult.path === false\n\t\t\t\t\t? false\n\t\t\t\t\t: `${result.path.replace(/#/g, \"\\0#\")}${\n\t\t\t\t\t\t\tresult.query ? result.query.replace(/#/g, \"\\0#\") : \"\"\n\t\t\t\t\t\t}${result.fragment || \"\"}`,\n\t\t\t\tresult,\n\t\t\t);\n\n\t\t/**\n\t\t * @param {string[]} log logs\n\t\t * @returns {void}\n\t\t */\n\t\tconst finishWithoutResolve = (log) => {\n\t\t\t/**\n\t\t\t * @type {ErrorWithDetail}\n\t\t\t */\n\t\t\tconst error = new Error(`Can't ${message}`);\n\t\t\terror.details = log.join(\"\\n\");\n\t\t\tthis.hooks.noResolve.call(obj, error);\n\t\t\treturn callback(error);\n\t\t};\n\n\t\tif (resolveContext.log) {\n\t\t\t// We need log anyway to capture it in case of an error\n\t\t\tconst parentLog = resolveContext.log;\n\t\t\t/** @type {string[]} */\n\t\t\tconst log = [];\n\t\t\treturn this.doResolve(\n\t\t\t\tthis.hooks.resolve,\n\t\t\t\tobj,\n\t\t\t\tmessage,\n\t\t\t\t{\n\t\t\t\t\tlog: (msg) => {\n\t\t\t\t\t\tparentLog(msg);\n\t\t\t\t\t\tlog.push(msg);\n\t\t\t\t\t},\n\t\t\t\t\tyield: yield_,\n\t\t\t\t\tfileDependencies: resolveContext.fileDependencies,\n\t\t\t\t\tcontextDependencies: resolveContext.contextDependencies,\n\t\t\t\t\tmissingDependencies: resolveContext.missingDependencies,\n\t\t\t\t\tstack: resolveContext.stack,\n\t\t\t\t},\n\t\t\t\t(err, result) => {\n\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\tif (yieldCalled || (result && yield_)) {\n\t\t\t\t\t\treturn /** @type {ResolveContextYield} */ (finishYield)(\n\t\t\t\t\t\t\t/** @type {ResolveRequest} */ (result),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) return finishResolved(result);\n\n\t\t\t\t\treturn finishWithoutResolve(log);\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\t\t// Try to resolve assuming there is no error\n\t\t// We don't log stuff in this case\n\t\treturn this.doResolve(\n\t\t\tthis.hooks.resolve,\n\t\t\tobj,\n\t\t\tmessage,\n\t\t\t{\n\t\t\t\tlog: undefined,\n\t\t\t\tyield: yield_,\n\t\t\t\tfileDependencies: resolveContext.fileDependencies,\n\t\t\t\tcontextDependencies: resolveContext.contextDependencies,\n\t\t\t\tmissingDependencies: resolveContext.missingDependencies,\n\t\t\t\tstack: resolveContext.stack,\n\t\t\t},\n\t\t\t(err, result) => {\n\t\t\t\tif (err) return callback(err);\n\n\t\t\t\tif (yieldCalled || (result && yield_)) {\n\t\t\t\t\treturn /** @type {ResolveContextYield} */ (finishYield)(\n\t\t\t\t\t\t/** @type {ResolveRequest} */ (result),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (result) return finishResolved(result);\n\n\t\t\t\t// log is missing for the error details\n\t\t\t\t// so we redo the resolving for the log info\n\t\t\t\t// this is more expensive to the success case\n\t\t\t\t// is assumed by default\n\t\t\t\t/** @type {string[]} */\n\t\t\t\tconst log = [];\n\n\t\t\t\treturn this.doResolve(\n\t\t\t\t\tthis.hooks.resolve,\n\t\t\t\t\tobj,\n\t\t\t\t\tmessage,\n\t\t\t\t\t{\n\t\t\t\t\t\tlog: (msg) => log.push(msg),\n\t\t\t\t\t\tyield: yield_,\n\t\t\t\t\t\tstack: resolveContext.stack,\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t// In a case that there is a race condition and yield will be called\n\t\t\t\t\t\tif (yieldCalled || (result && yield_)) {\n\t\t\t\t\t\t\treturn /** @type {ResolveContextYield} */ (finishYield)(\n\t\t\t\t\t\t\t\t/** @type {ResolveRequest} */ (result),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn finishWithoutResolve(log);\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * @param {ResolveStepHook} hook hook\n\t * @param {ResolveRequest} request request\n\t * @param {null|string} message string\n\t * @param {ResolveContext} resolveContext resolver context\n\t * @param {(err?: null|Error, result?: ResolveRequest) => void} callback callback\n\t * @returns {void}\n\t */\n\tdoResolve(hook, request, message, resolveContext, callback) {\n\t\tconst stackEntry = Resolver.createStackEntry(hook, request);\n\n\t\t/** @type {Set<string> | undefined} */\n\t\tlet newStack;\n\t\tif (resolveContext.stack) {\n\t\t\tnewStack = new Set(resolveContext.stack);\n\t\t\tif (resolveContext.stack.has(stackEntry)) {\n\t\t\t\t/**\n\t\t\t\t * Prevent recursion\n\t\t\t\t * @type {Error & {recursion?: boolean}}\n\t\t\t\t */\n\t\t\t\tconst recursionError = new Error(\n\t\t\t\t\t`Recursion in resolving\\nStack:\\n  ${[...newStack].join(\"\\n  \")}`,\n\t\t\t\t);\n\t\t\t\trecursionError.recursion = true;\n\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\tresolveContext.log(\"abort resolving because of recursion\");\n\t\t\t\t}\n\t\t\t\treturn callback(recursionError);\n\t\t\t}\n\t\t\tnewStack.add(stackEntry);\n\t\t} else {\n\t\t\t// creating a set with new Set([item])\n\t\t\t// allocates a new array that has to be garbage collected\n\t\t\t// this is an EXTREMELY hot path, so let's avoid it\n\t\t\tnewStack = new Set();\n\t\t\tnewStack.add(stackEntry);\n\t\t}\n\t\tthis.hooks.resolveStep.call(hook, request);\n\n\t\tif (hook.isUsed()) {\n\t\t\tconst innerContext = createInnerContext(\n\t\t\t\t{\n\t\t\t\t\tlog: resolveContext.log,\n\t\t\t\t\tyield: resolveContext.yield,\n\t\t\t\t\tfileDependencies: resolveContext.fileDependencies,\n\t\t\t\t\tcontextDependencies: resolveContext.contextDependencies,\n\t\t\t\t\tmissingDependencies: resolveContext.missingDependencies,\n\t\t\t\t\tstack: newStack,\n\t\t\t\t},\n\t\t\t\tmessage,\n\t\t\t);\n\t\t\treturn hook.callAsync(request, innerContext, (err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tif (result) return callback(null, result);\n\t\t\t\tcallback();\n\t\t\t});\n\t\t}\n\t\tcallback();\n\t}\n\n\t/**\n\t * @param {string} identifier identifier\n\t * @returns {ParsedIdentifier} parsed identifier\n\t */\n\tparse(identifier) {\n\t\tconst part = {\n\t\t\trequest: \"\",\n\t\t\tquery: \"\",\n\t\t\tfragment: \"\",\n\t\t\tmodule: false,\n\t\t\tdirectory: false,\n\t\t\tfile: false,\n\t\t\tinternal: false,\n\t\t};\n\n\t\tconst parsedIdentifier = parseIdentifier(identifier);\n\n\t\tif (!parsedIdentifier) return part;\n\n\t\t[part.request, part.query, part.fragment] = parsedIdentifier;\n\n\t\tif (part.request.length > 0) {\n\t\t\tpart.internal = this.isPrivate(identifier);\n\t\t\tpart.module = this.isModule(part.request);\n\t\t\tpart.directory = this.isDirectory(part.request);\n\t\t\tif (part.directory) {\n\t\t\t\tpart.request = part.request.slice(0, -1);\n\t\t\t}\n\t\t}\n\n\t\treturn part;\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @returns {boolean} true, if the path is a module\n\t */\n\tisModule(path) {\n\t\treturn getType(path) === PathType.Normal;\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @returns {boolean} true, if the path is private\n\t */\n\tisPrivate(path) {\n\t\treturn getType(path) === PathType.Internal;\n\t}\n\n\t/**\n\t * @param {string} path a path\n\t * @returns {boolean} true, if the path is a directory path\n\t */\n\tisDirectory(path) {\n\t\treturn path.endsWith(\"/\");\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @param {string} request request\n\t * @returns {string} joined path\n\t */\n\tjoin(path, request) {\n\t\treturn join(path, request);\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @returns {string} normalized path\n\t */\n\tnormalize(path) {\n\t\treturn normalize(path);\n\t}\n}\n\nmodule.exports = Resolver;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAM;EAAEA,mBAAmB;EAAEC,eAAe;EAAEC;AAAS,CAAC,GAAGC,OAAO,CAAC,SAAS,CAAC;AAC7E,MAAMC,kBAAkB,GAAGD,OAAO,CAAC,sBAAsB,CAAC;AAC1D,MAAM;EAAEE;AAAgB,CAAC,GAAGF,OAAO,CAAC,mBAAmB,CAAC;AACxD,MAAM;EACLG,QAAQ;EACRC,UAAU,EAAEC,IAAI;EAChBC,OAAO;EACPC;AACD,CAAC,GAAGP,OAAO,CAAC,aAAa,CAAC;;AAE1B;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAASQ,WAAWA,CAACC,GAAG,EAAE;EACzB,OAAOA,GAAG,CAACC,OAAO,CAAC,WAAW,EAAGD,GAAG,IAAKA,GAAG,CAACE,KAAK,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAAC;AACrE;AAEA,MAAMC,QAAQ,CAAC;EACd;AACD;AACA;AACA;AACA;EACC,OAAOC,gBAAgBA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACtC,OAAO,GAAGD,IAAI,CAACE,IAAI,MAAMD,OAAO,CAACE,IAAI,KAAKF,OAAO,CAACA,OAAO,IAAI,EAAE,GAC9DA,OAAO,CAACG,KAAK,IAAI,EAAE,GACjBH,OAAO,CAACI,QAAQ,IAAI,EAAE,GAAGJ,OAAO,CAACK,SAAS,GAAG,YAAY,GAAG,EAAE,GAChEL,OAAO,CAACM,MAAM,GAAG,SAAS,GAAG,EAAE,EAC9B;EACH;;EAEA;AACD;AACA;AACA;EACCC,WAAWA,CAACC,UAAU,EAAEC,OAAO,EAAE;IAChC,IAAI,CAACD,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB;IACA,IAAI,CAACC,KAAK,GAAG;MACZC,WAAW,EAAE,IAAI5B,QAAQ,CAAC,CAAC,MAAM,EAAE,SAAS,CAAC,EAAE,aAAa,CAAC;MAC7D6B,SAAS,EAAE,IAAI7B,QAAQ,CAAC,CAAC,SAAS,EAAE,OAAO,CAAC,EAAE,WAAW,CAAC;MAC1D8B,OAAO,EAAE,IAAIhC,mBAAmB,CAC/B,CAAC,SAAS,EAAE,gBAAgB,CAAC,EAC7B,SACD,CAAC;MACDiC,MAAM,EAAE,IAAIhC,eAAe,CAAC,CAAC,QAAQ,EAAE,gBAAgB,CAAC,EAAE,QAAQ;IACnE,CAAC;EACF;;EAEA;AACD;AACA;AACA;EACCiC,UAAUA,CAACd,IAAI,EAAE;IAChB,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC7B,OAAOA,IAAI;IACZ;IACAA,IAAI,GAAGT,WAAW,CAACS,IAAI,CAAC;IACxB,IAAIA,IAAI,CAACe,UAAU,CAAC,QAAQ,CAAC,EAAE;MAC9B,OAAO,8BACN,IAAI,CAACD,UAAU,CAACd,IAAI,CAAC,CAAC,CAAC,CAACgB,WAAW,CAAC,CAAC,GAAGhB,IAAI,CAACN,KAAK,CAAC,CAAC,CAAC,CAAC,CAACuB,WAAW,CAAC;QAClEC,KAAK,EAAE,CAAC;MACT,CAAC,CAAC;IAEJ;IACA,IAAIlB,IAAI,CAACe,UAAU,CAAC,OAAO,CAAC,EAAE;MAC7B,OAAO,8BACN,IAAI,CAACD,UAAU,CAACd,IAAI,CAAC,CAAC,CAAC,CAACgB,WAAW,CAAC,CAAC,GAAGhB,IAAI,CAACN,KAAK,CAAC,CAAC,CAAC,CAAC,CAACuB,WAAW,CAAC;QAClEC,KAAK,EAAE;MACR,CAAC,CAAC;IAEJ;IACA;IACA,MAAMpB,IAAI,GAAG,wCAA0C,IAAI,CAACW,KAAK,CAAET,IAAI,CAAC;IACxE,IAAI,CAACF,IAAI,EAAE;MACV;MACC,IAAI,CAACW,KAAK,CAAET,IAAI,CAAC,GAAG,IAAIpB,mBAAmB,CAC3C,CAAC,SAAS,EAAE,gBAAgB,CAAC,EAC7BoB,IACD,CAAC;MAED,OAAO,wCAA0C,IAAI,CAACS,KAAK,CAAET,IAAI,CAAC;IACnE;IACA,OAAOF,IAAI;EACZ;;EAEA;AACD;AACA;AACA;EACCqB,OAAOA,CAACnB,IAAI,EAAE;IACb,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC7B,OAAOA,IAAI;IACZ;IACAA,IAAI,GAAGT,WAAW,CAACS,IAAI,CAAC;IACxB,IAAIA,IAAI,CAACe,UAAU,CAAC,QAAQ,CAAC,EAAE;MAC9B,OAAO,8BACN,IAAI,CAACI,OAAO,CAACnB,IAAI,CAAC,CAAC,CAAC,CAACgB,WAAW,CAAC,CAAC,GAAGhB,IAAI,CAACN,KAAK,CAAC,CAAC,CAAC,CAAC,CAACuB,WAAW,CAAC;QAC/DC,KAAK,EAAE,CAAC;MACT,CAAC,CAAC;IAEJ;IACA,IAAIlB,IAAI,CAACe,UAAU,CAAC,OAAO,CAAC,EAAE;MAC7B,OAAO,8BACN,IAAI,CAACI,OAAO,CAACnB,IAAI,CAAC,CAAC,CAAC,CAACgB,WAAW,CAAC,CAAC,GAAGhB,IAAI,CAACN,KAAK,CAAC,CAAC,CAAC,CAAC,CAACuB,WAAW,CAAC;QAC/DC,KAAK,EAAE;MACR,CAAC,CAAC;IAEJ;IACA;IACA,MAAMpB,IAAI,GAAG,wCAA0C,IAAI,CAACW,KAAK,CAAET,IAAI,CAAC;IACxE,IAAI,CAACF,IAAI,EAAE;MACV,MAAM,IAAIsB,KAAK,CAAC,QAAQpB,IAAI,gBAAgB,CAAC;IAC9C;IACA,OAAOF,IAAI;EACZ;;EAEA;AACD;AACA;AACA;AACA;AACA;EACCuB,WAAWA,CAACC,OAAO,EAAErB,IAAI,EAAEF,OAAO,EAAE;IACnC;IACA,IAAIwB,GAAG;IACP;IACA,IAAIV,MAAM;IACV,IAAIW,IAAI,GAAG,KAAK;IAChB,IAAI,CAACZ,OAAO,CAACU,OAAO,EAAErB,IAAI,EAAEF,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC0B,IAAI,EAAEC,CAAC,KAAK;MACrDH,GAAG,GAAGE,IAAI;MACVZ,MAAM,GAAGa,CAAC;MACVF,IAAI,GAAG,IAAI;IACZ,CAAC,CAAC;IACF,IAAI,CAACA,IAAI,EAAE;MACV,MAAM,IAAIJ,KAAK,CACd,yEACD,CAAC;IACF;IACA,IAAIG,GAAG,EAAE,MAAMA,GAAG;IAClB,IAAIV,MAAM,KAAKc,SAAS,EAAE,MAAM,IAAIP,KAAK,CAAC,WAAW,CAAC;IACtD,OAAOP,MAAM;EACd;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;EACCD,OAAOA,CAACU,OAAO,EAAErB,IAAI,EAAEF,OAAO,EAAE6B,cAAc,EAAEC,QAAQ,EAAE;IACzD,IAAI,CAACP,OAAO,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;MAC5C,OAAOO,QAAQ,CAAC,IAAIT,KAAK,CAAC,mCAAmC,CAAC,CAAC;IAChE;IACA,IAAI,OAAOnB,IAAI,KAAK,QAAQ,EAAE;MAC7B,OAAO4B,QAAQ,CAAC,IAAIT,KAAK,CAAC,+BAA+B,CAAC,CAAC;IAC5D;IACA,IAAI,OAAOrB,OAAO,KAAK,QAAQ,EAAE;MAChC,OAAO8B,QAAQ,CAAC,IAAIT,KAAK,CAAC,kCAAkC,CAAC,CAAC;IAC/D;IACA,IAAI,CAACQ,cAAc,EAAE;MACpB,OAAOC,QAAQ,CAAC,IAAIT,KAAK,CAAC,oCAAoC,CAAC,CAAC;IACjE;;IAEA;IACA,MAAMU,GAAG,GAAG;MACXR,OAAO;MACPrB,IAAI;MACJF;IACD,CAAC;;IAED;IACA,IAAIgC,MAAM;IACV,IAAIC,WAAW,GAAG,KAAK;IACvB;IACA,IAAIC,WAAW;IACf,IAAI,OAAOL,cAAc,CAACM,KAAK,KAAK,UAAU,EAAE;MAC/C,MAAMC,GAAG,GAAGP,cAAc,CAACM,KAAK;MAChC;AACH;AACA;MACGH,MAAM,GAAID,GAAG,IAAK;QACjBK,GAAG,CAACL,GAAG,CAAC;QACRE,WAAW,GAAG,IAAI;MACnB,CAAC;MACD;AACH;AACA;AACA;MACGC,WAAW,GAAIpB,MAAM,IAAK;QACzB,IAAIA,MAAM,EAAE;UACX,kCAAoCkB,MAAM,CAAElB,MAAM,CAAC;QACpD;QACAgB,QAAQ,CAAC,IAAI,CAAC;MACf,CAAC;IACF;IAEA,MAAMO,OAAO,GAAG,YAAYrC,OAAO,SAASE,IAAI,GAAG;;IAEnD;AACF;AACA;AACA;IACE,MAAMoC,cAAc,GAAIxB,MAAM,IAC7BgB,QAAQ,CACP,IAAI,EACJhB,MAAM,CAACZ,IAAI,KAAK,KAAK,GAClB,KAAK,GACL,GAAGY,MAAM,CAACZ,IAAI,CAACR,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,GACnCoB,MAAM,CAACX,KAAK,GAAGW,MAAM,CAACX,KAAK,CAACT,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG,EAAE,GACnDoB,MAAM,CAACV,QAAQ,IAAI,EAAE,EAAE,EAC5BU,MACD,CAAC;;IAEF;AACF;AACA;AACA;IACE,MAAMyB,oBAAoB,GAAIC,GAAG,IAAK;MACrC;AACH;AACA;MACG,MAAMC,KAAK,GAAG,IAAIpB,KAAK,CAAC,SAASgB,OAAO,EAAE,CAAC;MAC3CI,KAAK,CAACC,OAAO,GAAGF,GAAG,CAACnD,IAAI,CAAC,IAAI,CAAC;MAC9B,IAAI,CAACqB,KAAK,CAACE,SAAS,CAAC+B,IAAI,CAACZ,GAAG,EAAEU,KAAK,CAAC;MACrC,OAAOX,QAAQ,CAACW,KAAK,CAAC;IACvB,CAAC;IAED,IAAIZ,cAAc,CAACW,GAAG,EAAE;MACvB;MACA,MAAMI,SAAS,GAAGf,cAAc,CAACW,GAAG;MACpC;MACA,MAAMA,GAAG,GAAG,EAAE;MACd,OAAO,IAAI,CAACK,SAAS,CACpB,IAAI,CAACnC,KAAK,CAACG,OAAO,EAClBkB,GAAG,EACHM,OAAO,EACP;QACCG,GAAG,EAAGM,GAAG,IAAK;UACbF,SAAS,CAACE,GAAG,CAAC;UACdN,GAAG,CAACO,IAAI,CAACD,GAAG,CAAC;QACd,CAAC;QACDX,KAAK,EAAEH,MAAM;QACbgB,gBAAgB,EAAEnB,cAAc,CAACmB,gBAAgB;QACjDC,mBAAmB,EAAEpB,cAAc,CAACoB,mBAAmB;QACvDC,mBAAmB,EAAErB,cAAc,CAACqB,mBAAmB;QACvDC,KAAK,EAAEtB,cAAc,CAACsB;MACvB,CAAC,EACD,CAAC3B,GAAG,EAAEV,MAAM,KAAK;QAChB,IAAIU,GAAG,EAAE,OAAOM,QAAQ,CAACN,GAAG,CAAC;QAE7B,IAAIS,WAAW,IAAKnB,MAAM,IAAIkB,MAAO,EAAE;UACtC,OAAO,kCAAoCE,WAAW,CACrD,6BAA+BpB,MAChC,CAAC;QACF;QAEA,IAAIA,MAAM,EAAE,OAAOwB,cAAc,CAACxB,MAAM,CAAC;QAEzC,OAAOyB,oBAAoB,CAACC,GAAG,CAAC;MACjC,CACD,CAAC;IACF;IACA;IACA;IACA,OAAO,IAAI,CAACK,SAAS,CACpB,IAAI,CAACnC,KAAK,CAACG,OAAO,EAClBkB,GAAG,EACHM,OAAO,EACP;MACCG,GAAG,EAAEZ,SAAS;MACdO,KAAK,EAAEH,MAAM;MACbgB,gBAAgB,EAAEnB,cAAc,CAACmB,gBAAgB;MACjDC,mBAAmB,EAAEpB,cAAc,CAACoB,mBAAmB;MACvDC,mBAAmB,EAAErB,cAAc,CAACqB,mBAAmB;MACvDC,KAAK,EAAEtB,cAAc,CAACsB;IACvB,CAAC,EACD,CAAC3B,GAAG,EAAEV,MAAM,KAAK;MAChB,IAAIU,GAAG,EAAE,OAAOM,QAAQ,CAACN,GAAG,CAAC;MAE7B,IAAIS,WAAW,IAAKnB,MAAM,IAAIkB,MAAO,EAAE;QACtC,OAAO,kCAAoCE,WAAW,CACrD,6BAA+BpB,MAChC,CAAC;MACF;MAEA,IAAIA,MAAM,EAAE,OAAOwB,cAAc,CAACxB,MAAM,CAAC;;MAEzC;MACA;MACA;MACA;MACA;MACA,MAAM0B,GAAG,GAAG,EAAE;MAEd,OAAO,IAAI,CAACK,SAAS,CACpB,IAAI,CAACnC,KAAK,CAACG,OAAO,EAClBkB,GAAG,EACHM,OAAO,EACP;QACCG,GAAG,EAAGM,GAAG,IAAKN,GAAG,CAACO,IAAI,CAACD,GAAG,CAAC;QAC3BX,KAAK,EAAEH,MAAM;QACbmB,KAAK,EAAEtB,cAAc,CAACsB;MACvB,CAAC,EACD,CAAC3B,GAAG,EAAEV,MAAM,KAAK;QAChB,IAAIU,GAAG,EAAE,OAAOM,QAAQ,CAACN,GAAG,CAAC;;QAE7B;QACA,IAAIS,WAAW,IAAKnB,MAAM,IAAIkB,MAAO,EAAE;UACtC,OAAO,kCAAoCE,WAAW,CACrD,6BAA+BpB,MAChC,CAAC;QACF;QAEA,OAAOyB,oBAAoB,CAACC,GAAG,CAAC;MACjC,CACD,CAAC;IACF,CACD,CAAC;EACF;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;EACCK,SAASA,CAAC9C,IAAI,EAAEC,OAAO,EAAEqC,OAAO,EAAER,cAAc,EAAEC,QAAQ,EAAE;IAC3D,MAAMsB,UAAU,GAAGvD,QAAQ,CAACC,gBAAgB,CAACC,IAAI,EAAEC,OAAO,CAAC;;IAE3D;IACA,IAAIqD,QAAQ;IACZ,IAAIxB,cAAc,CAACsB,KAAK,EAAE;MACzBE,QAAQ,GAAG,IAAIC,GAAG,CAACzB,cAAc,CAACsB,KAAK,CAAC;MACxC,IAAItB,cAAc,CAACsB,KAAK,CAACI,GAAG,CAACH,UAAU,CAAC,EAAE;QACzC;AACJ;AACA;AACA;QACI,MAAMI,cAAc,GAAG,IAAInC,KAAK,CAC/B,qCAAqC,CAAC,GAAGgC,QAAQ,CAAC,CAAChE,IAAI,CAAC,MAAM,CAAC,EAChE,CAAC;QACDmE,cAAc,CAACC,SAAS,GAAG,IAAI;QAC/B,IAAI5B,cAAc,CAACW,GAAG,EAAE;UACvBX,cAAc,CAACW,GAAG,CAAC,sCAAsC,CAAC;QAC3D;QACA,OAAOV,QAAQ,CAAC0B,cAAc,CAAC;MAChC;MACAH,QAAQ,CAACK,GAAG,CAACN,UAAU,CAAC;IACzB,CAAC,MAAM;MACN;MACA;MACA;MACAC,QAAQ,GAAG,IAAIC,GAAG,CAAC,CAAC;MACpBD,QAAQ,CAACK,GAAG,CAACN,UAAU,CAAC;IACzB;IACA,IAAI,CAAC1C,KAAK,CAACC,WAAW,CAACgC,IAAI,CAAC5C,IAAI,EAAEC,OAAO,CAAC;IAE1C,IAAID,IAAI,CAAC4D,MAAM,CAAC,CAAC,EAAE;MAClB,MAAMC,YAAY,GAAG3E,kBAAkB,CACtC;QACCuD,GAAG,EAAEX,cAAc,CAACW,GAAG;QACvBL,KAAK,EAAEN,cAAc,CAACM,KAAK;QAC3Ba,gBAAgB,EAAEnB,cAAc,CAACmB,gBAAgB;QACjDC,mBAAmB,EAAEpB,cAAc,CAACoB,mBAAmB;QACvDC,mBAAmB,EAAErB,cAAc,CAACqB,mBAAmB;QACvDC,KAAK,EAAEE;MACR,CAAC,EACDhB,OACD,CAAC;MACD,OAAOtC,IAAI,CAAC8D,SAAS,CAAC7D,OAAO,EAAE4D,YAAY,EAAE,CAACpC,GAAG,EAAEV,MAAM,KAAK;QAC7D,IAAIU,GAAG,EAAE,OAAOM,QAAQ,CAACN,GAAG,CAAC;QAC7B,IAAIV,MAAM,EAAE,OAAOgB,QAAQ,CAAC,IAAI,EAAEhB,MAAM,CAAC;QACzCgB,QAAQ,CAAC,CAAC;MACX,CAAC,CAAC;IACH;IACAA,QAAQ,CAAC,CAAC;EACX;;EAEA;AACD;AACA;AACA;EACCgC,KAAKA,CAACC,UAAU,EAAE;IACjB,MAAMC,IAAI,GAAG;MACZhE,OAAO,EAAE,EAAE;MACXG,KAAK,EAAE,EAAE;MACTC,QAAQ,EAAE,EAAE;MACZE,MAAM,EAAE,KAAK;MACbD,SAAS,EAAE,KAAK;MAChB4D,IAAI,EAAE,KAAK;MACXC,QAAQ,EAAE;IACX,CAAC;IAED,MAAMC,gBAAgB,GAAGjF,eAAe,CAAC6E,UAAU,CAAC;IAEpD,IAAI,CAACI,gBAAgB,EAAE,OAAOH,IAAI;IAElC,CAACA,IAAI,CAAChE,OAAO,EAAEgE,IAAI,CAAC7D,KAAK,EAAE6D,IAAI,CAAC5D,QAAQ,CAAC,GAAG+D,gBAAgB;IAE5D,IAAIH,IAAI,CAAChE,OAAO,CAACoE,MAAM,GAAG,CAAC,EAAE;MAC5BJ,IAAI,CAACE,QAAQ,GAAG,IAAI,CAACG,SAAS,CAACN,UAAU,CAAC;MAC1CC,IAAI,CAAC1D,MAAM,GAAG,IAAI,CAACgE,QAAQ,CAACN,IAAI,CAAChE,OAAO,CAAC;MACzCgE,IAAI,CAAC3D,SAAS,GAAG,IAAI,CAACkE,WAAW,CAACP,IAAI,CAAChE,OAAO,CAAC;MAC/C,IAAIgE,IAAI,CAAC3D,SAAS,EAAE;QACnB2D,IAAI,CAAChE,OAAO,GAAGgE,IAAI,CAAChE,OAAO,CAACL,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACzC;IACD;IAEA,OAAOqE,IAAI;EACZ;;EAEA;AACD;AACA;AACA;EACCM,QAAQA,CAACpE,IAAI,EAAE;IACd,OAAOZ,OAAO,CAACY,IAAI,CAAC,KAAKf,QAAQ,CAACqF,MAAM;EACzC;;EAEA;AACD;AACA;AACA;EACCH,SAASA,CAACnE,IAAI,EAAE;IACf,OAAOZ,OAAO,CAACY,IAAI,CAAC,KAAKf,QAAQ,CAACsF,QAAQ;EAC3C;;EAEA;AACD;AACA;AACA;EACCF,WAAWA,CAACrE,IAAI,EAAE;IACjB,OAAOA,IAAI,CAACwE,QAAQ,CAAC,GAAG,CAAC;EAC1B;;EAEA;AACD;AACA;AACA;AACA;EACCrF,IAAIA,CAACa,IAAI,EAAEF,OAAO,EAAE;IACnB,OAAOX,IAAI,CAACa,IAAI,EAAEF,OAAO,CAAC;EAC3B;;EAEA;AACD;AACA;AACA;EACCT,SAASA,CAACW,IAAI,EAAE;IACf,OAAOX,SAAS,CAACW,IAAI,CAAC;EACvB;AACD;AAEAI,MAAM,CAACqE,OAAO,GAAG9E,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}