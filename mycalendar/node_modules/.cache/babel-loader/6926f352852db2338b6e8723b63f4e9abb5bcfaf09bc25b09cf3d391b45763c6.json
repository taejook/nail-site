{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nconst forEachBail = require(\"./forEachBail\");\nconst {\n  processExportsField\n} = require(\"./util/entrypoints\");\nconst {\n  parseIdentifier\n} = require(\"./util/identifier\");\nconst {\n  deprecatedInvalidSegmentRegEx,\n  invalidSegmentRegEx\n} = require(\"./util/path\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").JsonObject} JsonObject */\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {import(\"./util/entrypoints\").ExportsField} ExportsField */\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n\nmodule.exports = class ExportsFieldPlugin {\n  /**\n   * @param {string | ResolveStepHook} source source\n   * @param {Set<string>} conditionNames condition names\n   * @param {string | string[]} fieldNamePath name path\n   * @param {string | ResolveStepHook} target target\n   */\n  constructor(source, conditionNames, fieldNamePath, target) {\n    this.source = source;\n    this.target = target;\n    this.conditionNames = conditionNames;\n    this.fieldName = fieldNamePath;\n    /** @type {WeakMap<JsonObject, FieldProcessor>} */\n    this.fieldProcessorCache = new WeakMap();\n  }\n\n  /**\n   * @param {Resolver} resolver the resolver\n   * @returns {void}\n   */\n  apply(resolver) {\n    const target = resolver.ensureHook(this.target);\n    resolver.getHook(this.source).tapAsync(\"ExportsFieldPlugin\", (request, resolveContext, callback) => {\n      // When there is no description file, abort\n      if (!request.descriptionFilePath) return callback();\n      if (\n      // When the description file is inherited from parent, abort\n      // (There is no description file inside of this package)\n      request.relativePath !== \".\" || request.request === undefined) {\n        return callback();\n      }\n      const remainingRequest = request.query || request.fragment ? (request.request === \".\" ? \"./\" : request.request) + request.query + request.fragment : request.request;\n      const exportsField = /** @type {ExportsField|null|undefined} */\n\n      DescriptionFileUtils.getField(/** @type {JsonObject} */request.descriptionFileData, this.fieldName);\n      if (!exportsField) return callback();\n      if (request.directory) {\n        return callback(new Error(`Resolving to directories is not possible with the exports field (request was ${remainingRequest}/)`));\n      }\n\n      /** @type {string[]} */\n      let paths;\n      /** @type {string | null} */\n      let usedField;\n      try {\n        // We attach the cache to the description file instead of the exportsField value\n        // because we use a WeakMap and the exportsField could be a string too.\n        // Description file is always an object when exports field can be accessed.\n        let fieldProcessor = this.fieldProcessorCache.get(/** @type {JsonObject} */request.descriptionFileData);\n        if (fieldProcessor === undefined) {\n          fieldProcessor = processExportsField(exportsField);\n          this.fieldProcessorCache.set(/** @type {JsonObject} */request.descriptionFileData, fieldProcessor);\n        }\n        [paths, usedField] = fieldProcessor(remainingRequest, this.conditionNames);\n      } catch (/** @type {unknown} */err) {\n        if (resolveContext.log) {\n          resolveContext.log(`Exports field in ${request.descriptionFilePath} can't be processed: ${err}`);\n        }\n        return callback(/** @type {Error} */err);\n      }\n      if (paths.length === 0) {\n        return callback(new Error(`Package path ${remainingRequest} is not exported from package ${request.descriptionFileRoot} (see exports field in ${request.descriptionFilePath})`));\n      }\n      forEachBail(paths,\n      /**\n       * @param {string} path path\n       * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback\n       * @param {number} i index\n       * @returns {void}\n       */\n      (path, callback, i) => {\n        const parsedIdentifier = parseIdentifier(path);\n        if (!parsedIdentifier) return callback();\n        const [relativePath, query, fragment] = parsedIdentifier;\n        if (relativePath.length === 0 || !relativePath.startsWith(\"./\")) {\n          if (paths.length === i) {\n            return callback(new Error(`Invalid \"exports\" target \"${path}\" defined for \"${usedField}\" in the package config ${request.descriptionFilePath}, targets must start with \"./\"`));\n          }\n          return callback();\n        }\n        if (invalidSegmentRegEx.exec(relativePath.slice(2)) !== null && deprecatedInvalidSegmentRegEx.test(relativePath.slice(2)) !== null) {\n          if (paths.length === i) {\n            return callback(new Error(`Invalid \"exports\" target \"${path}\" defined for \"${usedField}\" in the package config ${request.descriptionFilePath}, targets must start with \"./\"`));\n          }\n          return callback();\n        }\n\n        /** @type {ResolveRequest} */\n        const obj = {\n          ...request,\n          request: undefined,\n          path: resolver.join(/** @type {string} */request.descriptionFileRoot, relativePath),\n          relativePath,\n          query,\n          fragment\n        };\n        resolver.doResolve(target, obj, `using exports field: ${path}`, resolveContext, (err, result) => {\n          if (err) return callback(err);\n          // Don't allow to continue - https://github.com/webpack/enhanced-resolve/issues/400\n          if (result === undefined) return callback(null, null);\n          callback(null, result);\n        });\n      },\n      /**\n       * @param {(null | Error)=} err error\n       * @param {(null | ResolveRequest)=} result result\n       * @returns {void}\n       */\n      (err, result) => callback(err, result || null));\n    });\n  }\n};","map":{"version":3,"names":["DescriptionFileUtils","require","forEachBail","processExportsField","parseIdentifier","deprecatedInvalidSegmentRegEx","invalidSegmentRegEx","module","exports","ExportsFieldPlugin","constructor","source","conditionNames","fieldNamePath","target","fieldName","fieldProcessorCache","WeakMap","apply","resolver","ensureHook","getHook","tapAsync","request","resolveContext","callback","descriptionFilePath","relativePath","undefined","remainingRequest","query","fragment","exportsField","getField","descriptionFileData","directory","Error","paths","usedField","fieldProcessor","get","set","err","log","length","descriptionFileRoot","path","i","parsedIdentifier","startsWith","exec","slice","test","obj","join","doResolve","result"],"sources":["C:/Users/dah03/calendar/mycalendar/node_modules/enhanced-resolve/lib/ExportsFieldPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nconst forEachBail = require(\"./forEachBail\");\nconst { processExportsField } = require(\"./util/entrypoints\");\nconst { parseIdentifier } = require(\"./util/identifier\");\nconst {\n\tdeprecatedInvalidSegmentRegEx,\n\tinvalidSegmentRegEx,\n} = require(\"./util/path\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").JsonObject} JsonObject */\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {import(\"./util/entrypoints\").ExportsField} ExportsField */\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n\nmodule.exports = class ExportsFieldPlugin {\n\t/**\n\t * @param {string | ResolveStepHook} source source\n\t * @param {Set<string>} conditionNames condition names\n\t * @param {string | string[]} fieldNamePath name path\n\t * @param {string | ResolveStepHook} target target\n\t */\n\tconstructor(source, conditionNames, fieldNamePath, target) {\n\t\tthis.source = source;\n\t\tthis.target = target;\n\t\tthis.conditionNames = conditionNames;\n\t\tthis.fieldName = fieldNamePath;\n\t\t/** @type {WeakMap<JsonObject, FieldProcessor>} */\n\t\tthis.fieldProcessorCache = new WeakMap();\n\t}\n\n\t/**\n\t * @param {Resolver} resolver the resolver\n\t * @returns {void}\n\t */\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ExportsFieldPlugin\", (request, resolveContext, callback) => {\n\t\t\t\t// When there is no description file, abort\n\t\t\t\tif (!request.descriptionFilePath) return callback();\n\t\t\t\tif (\n\t\t\t\t\t// When the description file is inherited from parent, abort\n\t\t\t\t\t// (There is no description file inside of this package)\n\t\t\t\t\trequest.relativePath !== \".\" ||\n\t\t\t\t\trequest.request === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\n\t\t\t\tconst remainingRequest =\n\t\t\t\t\trequest.query || request.fragment\n\t\t\t\t\t\t? (request.request === \".\" ? \"./\" : request.request) +\n\t\t\t\t\t\t\trequest.query +\n\t\t\t\t\t\t\trequest.fragment\n\t\t\t\t\t\t: request.request;\n\t\t\t\tconst exportsField =\n\t\t\t\t\t/** @type {ExportsField|null|undefined} */\n\t\t\t\t\t(\n\t\t\t\t\t\tDescriptionFileUtils.getField(\n\t\t\t\t\t\t\t/** @type {JsonObject} */ (request.descriptionFileData),\n\t\t\t\t\t\t\tthis.fieldName,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\tif (!exportsField) return callback();\n\n\t\t\t\tif (request.directory) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Resolving to directories is not possible with the exports field (request was ${remainingRequest}/)`,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t/** @type {string[]} */\n\t\t\t\tlet paths;\n\t\t\t\t/** @type {string | null} */\n\t\t\t\tlet usedField;\n\n\t\t\t\ttry {\n\t\t\t\t\t// We attach the cache to the description file instead of the exportsField value\n\t\t\t\t\t// because we use a WeakMap and the exportsField could be a string too.\n\t\t\t\t\t// Description file is always an object when exports field can be accessed.\n\t\t\t\t\tlet fieldProcessor = this.fieldProcessorCache.get(\n\t\t\t\t\t\t/** @type {JsonObject} */ (request.descriptionFileData),\n\t\t\t\t\t);\n\t\t\t\t\tif (fieldProcessor === undefined) {\n\t\t\t\t\t\tfieldProcessor = processExportsField(exportsField);\n\t\t\t\t\t\tthis.fieldProcessorCache.set(\n\t\t\t\t\t\t\t/** @type {JsonObject} */ (request.descriptionFileData),\n\t\t\t\t\t\t\tfieldProcessor,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t[paths, usedField] = fieldProcessor(\n\t\t\t\t\t\tremainingRequest,\n\t\t\t\t\t\tthis.conditionNames,\n\t\t\t\t\t);\n\t\t\t\t} catch (/** @type {unknown} */ err) {\n\t\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t`Exports field in ${request.descriptionFilePath} can't be processed: ${err}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn callback(/** @type {Error} */ (err));\n\t\t\t\t}\n\n\t\t\t\tif (paths.length === 0) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Package path ${remainingRequest} is not exported from package ${request.descriptionFileRoot} (see exports field in ${request.descriptionFilePath})`,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tforEachBail(\n\t\t\t\t\tpaths,\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} path path\n\t\t\t\t\t * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback\n\t\t\t\t\t * @param {number} i index\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\t(path, callback, i) => {\n\t\t\t\t\t\tconst parsedIdentifier = parseIdentifier(path);\n\n\t\t\t\t\t\tif (!parsedIdentifier) return callback();\n\n\t\t\t\t\t\tconst [relativePath, query, fragment] = parsedIdentifier;\n\n\t\t\t\t\t\tif (relativePath.length === 0 || !relativePath.startsWith(\"./\")) {\n\t\t\t\t\t\t\tif (paths.length === i) {\n\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t`Invalid \"exports\" target \"${path}\" defined for \"${usedField}\" in the package config ${request.descriptionFilePath}, targets must start with \"./\"`,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tinvalidSegmentRegEx.exec(relativePath.slice(2)) !== null &&\n\t\t\t\t\t\t\tdeprecatedInvalidSegmentRegEx.test(relativePath.slice(2)) !== null\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (paths.length === i) {\n\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t`Invalid \"exports\" target \"${path}\" defined for \"${usedField}\" in the package config ${request.descriptionFilePath}, targets must start with \"./\"`,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/** @type {ResolveRequest} */\n\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\trequest: undefined,\n\t\t\t\t\t\t\tpath: resolver.join(\n\t\t\t\t\t\t\t\t/** @type {string} */ (request.descriptionFileRoot),\n\t\t\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\tfragment,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t`using exports field: ${path}`,\n\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t// Don't allow to continue - https://github.com/webpack/enhanced-resolve/issues/400\n\t\t\t\t\t\t\t\tif (result === undefined) return callback(null, null);\n\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {(null | Error)=} err error\n\t\t\t\t\t * @param {(null | ResolveRequest)=} result result\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\t(err, result) => callback(err, result || null),\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}