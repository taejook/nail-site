{"ast":null,"code":"// @ts-check\n/** @typedef {import('./index').Visitor} Visitor */\n\n/**\n * Composes multiple visitor objects into a single one.\n * @param {Visitor[]} visitors \n * @return {Visitor}\n */\nfunction composeVisitors(visitors) {\n  if (visitors.length === 1) {\n    return visitors[0];\n  }\n\n  /** @type Visitor */\n  let res = {};\n  composeSimpleVisitors(res, visitors, 'StyleSheet');\n  composeSimpleVisitors(res, visitors, 'StyleSheetExit');\n  composeObjectVisitors(res, visitors, 'Rule', ruleVisitor, wrapCustomAndUnknownAtRule);\n  composeObjectVisitors(res, visitors, 'RuleExit', ruleVisitor, wrapCustomAndUnknownAtRule);\n  composeObjectVisitors(res, visitors, 'Declaration', declarationVisitor, wrapCustomProperty);\n  composeObjectVisitors(res, visitors, 'DeclarationExit', declarationVisitor, wrapCustomProperty);\n  composeSimpleVisitors(res, visitors, 'Url');\n  composeSimpleVisitors(res, visitors, 'Color');\n  composeSimpleVisitors(res, visitors, 'Image');\n  composeSimpleVisitors(res, visitors, 'ImageExit');\n  composeSimpleVisitors(res, visitors, 'Length');\n  composeSimpleVisitors(res, visitors, 'Angle');\n  composeSimpleVisitors(res, visitors, 'Ratio');\n  composeSimpleVisitors(res, visitors, 'Resolution');\n  composeSimpleVisitors(res, visitors, 'Time');\n  composeSimpleVisitors(res, visitors, 'CustomIdent');\n  composeSimpleVisitors(res, visitors, 'DashedIdent');\n  composeArrayFunctions(res, visitors, 'MediaQuery');\n  composeArrayFunctions(res, visitors, 'MediaQueryExit');\n  composeSimpleVisitors(res, visitors, 'SupportsCondition');\n  composeSimpleVisitors(res, visitors, 'SupportsConditionExit');\n  composeArrayFunctions(res, visitors, 'Selector');\n  composeTokenVisitors(res, visitors, 'Token', 'token', false);\n  composeTokenVisitors(res, visitors, 'Function', 'function', false);\n  composeTokenVisitors(res, visitors, 'FunctionExit', 'function', true);\n  composeTokenVisitors(res, visitors, 'Variable', 'var', false);\n  composeTokenVisitors(res, visitors, 'VariableExit', 'var', true);\n  composeTokenVisitors(res, visitors, 'EnvironmentVariable', 'env', false);\n  composeTokenVisitors(res, visitors, 'EnvironmentVariableExit', 'env', true);\n  return res;\n}\nmodule.exports = composeVisitors;\nfunction wrapCustomAndUnknownAtRule(k, f) {\n  if (k === 'unknown') {\n    return value => f({\n      type: 'unknown',\n      value\n    });\n  }\n  if (k === 'custom') {\n    return value => f({\n      type: 'custom',\n      value\n    });\n  }\n  return f;\n}\nfunction wrapCustomProperty(k, f) {\n  return k === 'custom' ? value => f({\n    property: 'custom',\n    value\n  }) : f;\n}\n\n/**\n * @param {import('./index').Visitor['Rule']} f \n * @param {import('./ast').Rule} item \n */\nfunction ruleVisitor(f, item) {\n  if (typeof f === 'object') {\n    if (item.type === 'unknown') {\n      let v = f.unknown;\n      if (typeof v === 'object') {\n        v = v[item.value.name];\n      }\n      return v?.(item.value);\n    }\n    if (item.type === 'custom') {\n      let v = f.custom;\n      if (typeof v === 'object') {\n        v = v[item.value.name];\n      }\n      return v?.(item.value);\n    }\n    return f[item.type]?.(item);\n  }\n  return f?.(item);\n}\n\n/**\n * @param {import('./index').Visitor['Declaration']} f \n * @param {import('./ast').Declaration} item \n */\nfunction declarationVisitor(f, item) {\n  if (typeof f === 'object') {\n    /** @type {string} */\n    let name = item.property;\n    if (item.property === 'unparsed') {\n      name = item.value.propertyId.property;\n    } else if (item.property === 'custom') {\n      let v = f.custom;\n      if (typeof v === 'object') {\n        v = v[item.value.name];\n      }\n      return v?.(item.value);\n    }\n    return f[name]?.(item);\n  }\n  return f?.(item);\n}\n\n/**\n * \n * @param {Visitor[]} visitors \n * @param {string} key \n * @returns {[any[], boolean, Set<string>]}\n */\nfunction extractObjectsOrFunctions(visitors, key) {\n  let values = [];\n  let hasFunction = false;\n  let allKeys = new Set();\n  for (let visitor of visitors) {\n    let v = visitor[key];\n    if (v) {\n      if (typeof v === 'function') {\n        hasFunction = true;\n      } else {\n        for (let key in v) {\n          allKeys.add(key);\n        }\n      }\n      values.push(v);\n    }\n  }\n  return [values, hasFunction, allKeys];\n}\n\n/**\n * @template {keyof Visitor} K\n * @param {Visitor} res\n * @param {Visitor[]} visitors\n * @param {K} key\n * @param {(visitor: Visitor[K], item: any) => any | any[] | void} apply \n * @param {(k: string, f: any) => any} wrapKey \n */\nfunction composeObjectVisitors(res, visitors, key, apply, wrapKey) {\n  let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);\n  if (values.length === 0) {\n    return;\n  }\n  if (values.length === 1) {\n    res[key] = values[0];\n    return;\n  }\n  let f = createArrayVisitor(visitors, (visitor, item) => apply(visitor[key], item));\n  if (hasFunction) {\n    res[key] = f;\n  } else {\n    /** @type {any} */\n    let v = {};\n    for (let k of allKeys) {\n      v[k] = wrapKey(k, f);\n    }\n    res[key] = v;\n  }\n}\n\n/**\n * @param {Visitor} res \n * @param {Visitor[]} visitors \n * @param {string} key \n * @param {import('./ast').TokenOrValue['type']} type \n * @param {boolean} isExit \n */\nfunction composeTokenVisitors(res, visitors, key, type, isExit) {\n  let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);\n  if (values.length === 0) {\n    return;\n  }\n  if (values.length === 1) {\n    res[key] = values[0];\n    return;\n  }\n  let f = createTokenVisitor(visitors, type, isExit);\n  if (hasFunction) {\n    res[key] = f;\n  } else {\n    let v = {};\n    for (let key of allKeys) {\n      v[key] = f;\n    }\n    res[key] = v;\n  }\n}\n\n/**\n * @param {Visitor[]} visitors \n * @param {import('./ast').TokenOrValue['type']} type \n */\nfunction createTokenVisitor(visitors, type, isExit) {\n  let v = createArrayVisitor(visitors, (visitor, /** @type {import('./ast').TokenOrValue} */item) => {\n    let f;\n    switch (item.type) {\n      case 'token':\n        f = visitor.Token;\n        if (typeof f === 'object') {\n          f = f[item.value.type];\n        }\n        break;\n      case 'function':\n        f = isExit ? visitor.FunctionExit : visitor.Function;\n        if (typeof f === 'object') {\n          f = f[item.value.name];\n        }\n        break;\n      case 'var':\n        f = isExit ? visitor.VariableExit : visitor.Variable;\n        break;\n      case 'env':\n        f = isExit ? visitor.EnvironmentVariableExit : visitor.EnvironmentVariable;\n        if (typeof f === 'object') {\n          let name;\n          switch (item.value.name.type) {\n            case 'ua':\n            case 'unknown':\n              name = item.value.name.value;\n              break;\n            case 'custom':\n              name = item.value.name.ident;\n              break;\n          }\n          f = f[name];\n        }\n        break;\n      case 'color':\n        f = visitor.Color;\n        break;\n      case 'url':\n        f = visitor.Url;\n        break;\n      case 'length':\n        f = visitor.Length;\n        break;\n      case 'angle':\n        f = visitor.Angle;\n        break;\n      case 'time':\n        f = visitor.Time;\n        break;\n      case 'resolution':\n        f = visitor.Resolution;\n        break;\n      case 'dashed-ident':\n        f = visitor.DashedIdent;\n        break;\n    }\n    if (!f) {\n      return;\n    }\n    let res = f(item.value);\n    switch (item.type) {\n      case 'color':\n      case 'url':\n      case 'length':\n      case 'angle':\n      case 'time':\n      case 'resolution':\n      case 'dashed-ident':\n        if (Array.isArray(res)) {\n          res = res.map(value => ({\n            type: item.type,\n            value\n          }));\n        } else if (res) {\n          res = {\n            type: item.type,\n            value: res\n          };\n        }\n        break;\n    }\n    return res;\n  });\n  return value => v({\n    type,\n    value\n  });\n}\n\n/**\n * @param {Visitor[]} visitors \n * @param {string} key \n */\nfunction extractFunctions(visitors, key) {\n  let functions = [];\n  for (let visitor of visitors) {\n    let f = visitor[key];\n    if (f) {\n      functions.push(f);\n    }\n  }\n  return functions;\n}\n\n/**\n * @param {Visitor} res \n * @param {Visitor[]} visitors \n * @param {string} key \n */\nfunction composeSimpleVisitors(res, visitors, key) {\n  let functions = extractFunctions(visitors, key);\n  if (functions.length === 0) {\n    return;\n  }\n  if (functions.length === 1) {\n    res[key] = functions[0];\n    return;\n  }\n  res[key] = arg => {\n    let mutated = false;\n    for (let f of functions) {\n      let res = f(arg);\n      if (res) {\n        arg = res;\n        mutated = true;\n      }\n    }\n    return mutated ? arg : undefined;\n  };\n}\n\n/**\n * @param {Visitor} res \n * @param {Visitor[]} visitors \n * @param {string} key \n */\nfunction composeArrayFunctions(res, visitors, key) {\n  let functions = extractFunctions(visitors, key);\n  if (functions.length === 0) {\n    return;\n  }\n  if (functions.length === 1) {\n    res[key] = functions[0];\n    return;\n  }\n  res[key] = createArrayVisitor(functions, (f, item) => f(item));\n}\n\n/**\n * @template T\n * @template V\n * @param {T[]} visitors \n * @param {(visitor: T, item: V) => V | V[] | void} apply \n * @returns {(item: V) => V | V[] | void}\n */\nfunction createArrayVisitor(visitors, apply) {\n  let seen = new Bitset(visitors.length);\n  return arg => {\n    let arr = [arg];\n    let mutated = false;\n    seen.clear();\n    for (let i = 0; i < arr.length; i++) {\n      // For each value, call all visitors. If a visitor returns a new value,\n      // we start over, but skip the visitor that generated the value or saw\n      // it before (to avoid cycles). This way, visitors can be composed in any order. \n      for (let v = 0; v < visitors.length;) {\n        if (seen.get(v)) {\n          v++;\n          continue;\n        }\n        let item = arr[i];\n        let visitor = visitors[v];\n        let res = apply(visitor, item);\n        if (Array.isArray(res)) {\n          if (res.length === 0) {\n            arr.splice(i, 1);\n          } else if (res.length === 1) {\n            arr[i] = res[0];\n          } else {\n            arr.splice(i, 1, ...res);\n          }\n          mutated = true;\n          seen.set(v);\n          v = 0;\n        } else if (res) {\n          arr[i] = res;\n          mutated = true;\n          seen.set(v);\n          v = 0;\n        } else {\n          v++;\n        }\n      }\n    }\n    if (!mutated) {\n      return;\n    }\n    return arr.length === 1 ? arr[0] : arr;\n  };\n}\nclass Bitset {\n  constructor(maxBits = 32) {\n    this.bits = 0;\n    this.more = maxBits > 32 ? new Uint32Array(Math.ceil((maxBits - 32) / 32)) : null;\n  }\n\n  /** @param {number} bit */\n  get(bit) {\n    if (bit >= 32 && this.more) {\n      let i = Math.floor((bit - 32) / 32);\n      let b = bit % 32;\n      return Boolean(this.more[i] & 1 << b);\n    } else {\n      return Boolean(this.bits & 1 << bit);\n    }\n  }\n\n  /** @param {number} bit */\n  set(bit) {\n    if (bit >= 32 && this.more) {\n      let i = Math.floor((bit - 32) / 32);\n      let b = bit % 32;\n      this.more[i] |= 1 << b;\n    } else {\n      this.bits |= 1 << bit;\n    }\n  }\n  clear() {\n    this.bits = 0;\n    if (this.more) {\n      this.more.fill(0);\n    }\n  }\n}","map":{"version":3,"names":["composeVisitors","visitors","length","res","composeSimpleVisitors","composeObjectVisitors","ruleVisitor","wrapCustomAndUnknownAtRule","declarationVisitor","wrapCustomProperty","composeArrayFunctions","composeTokenVisitors","module","exports","k","f","value","type","property","item","v","unknown","name","custom","propertyId","extractObjectsOrFunctions","key","values","hasFunction","allKeys","Set","visitor","add","push","apply","wrapKey","createArrayVisitor","isExit","createTokenVisitor","Token","FunctionExit","Function","VariableExit","Variable","EnvironmentVariableExit","EnvironmentVariable","ident","Color","Url","Length","Angle","Time","Resolution","DashedIdent","Array","isArray","map","extractFunctions","functions","arg","mutated","undefined","seen","Bitset","arr","clear","i","get","splice","set","constructor","maxBits","bits","more","Uint32Array","Math","ceil","bit","floor","b","Boolean","fill"],"sources":["C:/Users/dah03/calendar/mycalendar/node_modules/lightningcss/node/composeVisitors.js"],"sourcesContent":["// @ts-check\n/** @typedef {import('./index').Visitor} Visitor */\n\n/**\n * Composes multiple visitor objects into a single one.\n * @param {Visitor[]} visitors \n * @return {Visitor}\n */\nfunction composeVisitors(visitors) {\n  if (visitors.length === 1) {\n    return visitors[0];\n  }\n\n  /** @type Visitor */\n  let res = {};\n  composeSimpleVisitors(res, visitors, 'StyleSheet');\n  composeSimpleVisitors(res, visitors, 'StyleSheetExit');\n  composeObjectVisitors(res, visitors, 'Rule', ruleVisitor, wrapCustomAndUnknownAtRule);\n  composeObjectVisitors(res, visitors, 'RuleExit', ruleVisitor, wrapCustomAndUnknownAtRule);\n  composeObjectVisitors(res, visitors, 'Declaration', declarationVisitor, wrapCustomProperty);\n  composeObjectVisitors(res, visitors, 'DeclarationExit', declarationVisitor, wrapCustomProperty);\n  composeSimpleVisitors(res, visitors, 'Url');\n  composeSimpleVisitors(res, visitors, 'Color');\n  composeSimpleVisitors(res, visitors, 'Image');\n  composeSimpleVisitors(res, visitors, 'ImageExit');\n  composeSimpleVisitors(res, visitors, 'Length');\n  composeSimpleVisitors(res, visitors, 'Angle');\n  composeSimpleVisitors(res, visitors, 'Ratio');\n  composeSimpleVisitors(res, visitors, 'Resolution');\n  composeSimpleVisitors(res, visitors, 'Time');\n  composeSimpleVisitors(res, visitors, 'CustomIdent');\n  composeSimpleVisitors(res, visitors, 'DashedIdent');\n  composeArrayFunctions(res, visitors, 'MediaQuery');\n  composeArrayFunctions(res, visitors, 'MediaQueryExit');\n  composeSimpleVisitors(res, visitors, 'SupportsCondition');\n  composeSimpleVisitors(res, visitors, 'SupportsConditionExit');\n  composeArrayFunctions(res, visitors, 'Selector');\n  composeTokenVisitors(res, visitors, 'Token', 'token', false);\n  composeTokenVisitors(res, visitors, 'Function', 'function', false);\n  composeTokenVisitors(res, visitors, 'FunctionExit', 'function', true);\n  composeTokenVisitors(res, visitors, 'Variable', 'var', false);\n  composeTokenVisitors(res, visitors, 'VariableExit', 'var', true);\n  composeTokenVisitors(res, visitors, 'EnvironmentVariable', 'env', false);\n  composeTokenVisitors(res, visitors, 'EnvironmentVariableExit', 'env', true);\n  return res;\n}\n\nmodule.exports = composeVisitors;\n\nfunction wrapCustomAndUnknownAtRule(k, f) {\n  if (k === 'unknown') {\n    return (value => f({ type: 'unknown', value }));\n  }\n  if (k === 'custom') {\n    return (value => f({ type: 'custom', value }));\n  }\n  return f;\n}\n\nfunction wrapCustomProperty(k, f) {\n  return k === 'custom' ? (value => f({ property: 'custom', value })) : f;\n}\n\n/**\n * @param {import('./index').Visitor['Rule']} f \n * @param {import('./ast').Rule} item \n */\nfunction ruleVisitor(f, item) {\n  if (typeof f === 'object') {\n    if (item.type === 'unknown') {\n      let v = f.unknown;\n      if (typeof v === 'object') {\n        v = v[item.value.name];\n      }\n      return v?.(item.value);\n    }\n    if (item.type === 'custom') {\n      let v = f.custom;\n      if (typeof v === 'object') {\n        v = v[item.value.name];\n      }\n      return v?.(item.value);\n    }\n    return f[item.type]?.(item);\n  }\n  return f?.(item);\n}\n\n/**\n * @param {import('./index').Visitor['Declaration']} f \n * @param {import('./ast').Declaration} item \n */\nfunction declarationVisitor(f, item) {\n  if (typeof f === 'object') {\n    /** @type {string} */\n    let name = item.property;\n    if (item.property === 'unparsed') {\n      name = item.value.propertyId.property;\n    } else if (item.property === 'custom') {\n      let v = f.custom;\n      if (typeof v === 'object') {\n        v = v[item.value.name];\n      }\n      return v?.(item.value);\n    }\n    return f[name]?.(item);\n  }\n  return f?.(item);\n}\n\n/**\n * \n * @param {Visitor[]} visitors \n * @param {string} key \n * @returns {[any[], boolean, Set<string>]}\n */\nfunction extractObjectsOrFunctions(visitors, key) {\n  let values = [];\n  let hasFunction = false;\n  let allKeys = new Set();\n  for (let visitor of visitors) {\n    let v = visitor[key];\n    if (v) {\n      if (typeof v === 'function') {\n        hasFunction = true;\n      } else {\n        for (let key in v) {\n          allKeys.add(key);\n        }\n      }\n      values.push(v);\n    }\n  }\n  return [values, hasFunction, allKeys];\n}\n\n/**\n * @template {keyof Visitor} K\n * @param {Visitor} res\n * @param {Visitor[]} visitors\n * @param {K} key\n * @param {(visitor: Visitor[K], item: any) => any | any[] | void} apply \n * @param {(k: string, f: any) => any} wrapKey \n */\nfunction composeObjectVisitors(res, visitors, key, apply, wrapKey) {\n  let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);\n  if (values.length === 0) {\n    return;\n  }\n\n  if (values.length === 1) {\n    res[key] = values[0];\n    return;\n  }\n\n  let f = createArrayVisitor(visitors, (visitor, item) => apply(visitor[key], item));\n  if (hasFunction) {\n    res[key] = f;\n  } else {\n    /** @type {any} */\n    let v = {};\n    for (let k of allKeys) {\n      v[k] = wrapKey(k, f);\n    }\n    res[key] = v;\n  }\n}\n\n/**\n * @param {Visitor} res \n * @param {Visitor[]} visitors \n * @param {string} key \n * @param {import('./ast').TokenOrValue['type']} type \n * @param {boolean} isExit \n */\nfunction composeTokenVisitors(res, visitors, key, type, isExit) {\n  let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);\n  if (values.length === 0) {\n    return;\n  }\n\n  if (values.length === 1) {\n    res[key] = values[0];\n    return;\n  }\n\n  let f = createTokenVisitor(visitors, type, isExit);\n  if (hasFunction) {\n    res[key] = f;\n  } else {\n    let v = {};\n    for (let key of allKeys) {\n      v[key] = f;\n    }\n    res[key] = v;\n  }\n}\n\n/**\n * @param {Visitor[]} visitors \n * @param {import('./ast').TokenOrValue['type']} type \n */\nfunction createTokenVisitor(visitors, type, isExit) {\n  let v = createArrayVisitor(visitors, (visitor, /** @type {import('./ast').TokenOrValue} */ item) => {\n    let f;\n    switch (item.type) {\n      case 'token':\n        f = visitor.Token;\n        if (typeof f === 'object') {\n          f = f[item.value.type];\n        }\n        break;\n      case 'function':\n        f = isExit ? visitor.FunctionExit : visitor.Function;\n        if (typeof f === 'object') {\n          f = f[item.value.name];\n        }\n        break;\n      case 'var':\n        f = isExit ? visitor.VariableExit : visitor.Variable;\n        break;\n      case 'env':\n        f = isExit ? visitor.EnvironmentVariableExit : visitor.EnvironmentVariable;\n        if (typeof f === 'object') {\n          let name;\n          switch (item.value.name.type) {\n            case 'ua':\n            case 'unknown':\n              name = item.value.name.value;\n              break;\n            case 'custom':\n              name = item.value.name.ident;\n              break;\n          }\n          f = f[name];\n        }\n        break;\n      case 'color':\n        f = visitor.Color;\n        break;\n      case 'url':\n        f = visitor.Url;\n        break;\n      case 'length':\n        f = visitor.Length;\n        break;\n      case 'angle':\n        f = visitor.Angle;\n        break;\n      case 'time':\n        f = visitor.Time;\n        break;\n      case 'resolution':\n        f = visitor.Resolution;\n        break;\n      case 'dashed-ident':\n        f = visitor.DashedIdent;\n        break;\n    }\n\n    if (!f) {\n      return;\n    }\n\n    let res = f(item.value);\n    switch (item.type) {\n      case 'color':\n      case 'url':\n      case 'length':\n      case 'angle':\n      case 'time':\n      case 'resolution':\n      case 'dashed-ident':\n        if (Array.isArray(res)) {\n          res = res.map(value => ({ type: item.type, value }))\n        } else if (res) {\n          res = { type: item.type, value: res };\n        }\n        break;\n    }\n\n    return res;\n  });\n\n  return value => v({ type, value });\n}\n\n/**\n * @param {Visitor[]} visitors \n * @param {string} key \n */\nfunction extractFunctions(visitors, key) {\n  let functions = [];\n  for (let visitor of visitors) {\n    let f = visitor[key];\n    if (f) {\n      functions.push(f);\n    }\n  }\n  return functions;\n}\n\n/**\n * @param {Visitor} res \n * @param {Visitor[]} visitors \n * @param {string} key \n */\nfunction composeSimpleVisitors(res, visitors, key) {\n  let functions = extractFunctions(visitors, key);\n  if (functions.length === 0) {\n    return;\n  }\n\n  if (functions.length === 1) {\n    res[key] = functions[0];\n    return;\n  }\n\n  res[key] = arg => {\n    let mutated = false;\n    for (let f of functions) {\n      let res = f(arg);\n      if (res) {\n        arg = res;\n        mutated = true;\n      }\n    }\n\n    return mutated ? arg : undefined;\n  };\n}\n\n/**\n * @param {Visitor} res \n * @param {Visitor[]} visitors \n * @param {string} key \n */\nfunction composeArrayFunctions(res, visitors, key) {\n  let functions = extractFunctions(visitors, key);\n  if (functions.length === 0) {\n    return;\n  }\n\n  if (functions.length === 1) {\n    res[key] = functions[0];\n    return;\n  }\n\n  res[key] = createArrayVisitor(functions, (f, item) => f(item));\n}\n\n/**\n * @template T\n * @template V\n * @param {T[]} visitors \n * @param {(visitor: T, item: V) => V | V[] | void} apply \n * @returns {(item: V) => V | V[] | void}\n */\nfunction createArrayVisitor(visitors, apply) {\n  let seen = new Bitset(visitors.length);\n  return arg => {\n    let arr = [arg];\n    let mutated = false;\n    seen.clear();\n    for (let i = 0; i < arr.length; i++) {\n      // For each value, call all visitors. If a visitor returns a new value,\n      // we start over, but skip the visitor that generated the value or saw\n      // it before (to avoid cycles). This way, visitors can be composed in any order. \n      for (let v = 0; v < visitors.length;) {\n        if (seen.get(v)) {\n          v++;\n          continue;\n        }\n\n        let item = arr[i];\n        let visitor = visitors[v];\n        let res = apply(visitor, item);\n        if (Array.isArray(res)) {\n          if (res.length === 0) {\n            arr.splice(i, 1);\n          } else if (res.length === 1) {\n            arr[i] = res[0];\n          } else {\n            arr.splice(i, 1, ...res);\n          }\n          mutated = true;\n          seen.set(v);\n          v = 0;\n        } else if (res) {\n          arr[i] = res;\n          mutated = true;\n          seen.set(v);\n          v = 0;\n        } else {\n          v++;\n        }\n      }\n    }\n\n    if (!mutated) {\n      return;\n    }\n\n    return arr.length === 1 ? arr[0] : arr;\n  };\n}\n\nclass Bitset {\n  constructor(maxBits = 32) {\n    this.bits = 0;\n    this.more = maxBits > 32 ? new Uint32Array(Math.ceil((maxBits - 32) / 32)) : null;\n  }\n\n  /** @param {number} bit */\n  get(bit) {\n    if (bit >= 32 && this.more) {\n      let i = Math.floor((bit - 32) / 32);\n      let b = bit % 32;\n      return Boolean(this.more[i] & (1 << b));\n    } else {\n      return Boolean(this.bits & (1 << bit));\n    }\n  }\n\n  /** @param {number} bit */\n  set(bit) {\n    if (bit >= 32 && this.more) {\n      let i = Math.floor((bit - 32) / 32);\n      let b = bit % 32;\n      this.more[i] |= 1 << b;\n    } else {\n      this.bits |= 1 << bit;\n    }\n  }\n\n  clear() {\n    this.bits = 0;\n    if (this.more) {\n      this.more.fill(0);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}