{"ast":null,"code":"import { encode } from '@jridgewell/sourcemap-codec';\nclass BitSet {\n  constructor(arg) {\n    this.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n  }\n  add(n) {\n    this.bits[n >> 5] |= 1 << (n & 31);\n  }\n  has(n) {\n    return !!(this.bits[n >> 5] & 1 << (n & 31));\n  }\n}\nclass Chunk {\n  constructor(start, end, content) {\n    this.start = start;\n    this.end = end;\n    this.original = content;\n    this.intro = '';\n    this.outro = '';\n    this.content = content;\n    this.storeName = false;\n    this.edited = false;\n    {\n      this.previous = null;\n      this.next = null;\n    }\n  }\n  appendLeft(content) {\n    this.outro += content;\n  }\n  appendRight(content) {\n    this.intro = this.intro + content;\n  }\n  clone() {\n    const chunk = new Chunk(this.start, this.end, this.original);\n    chunk.intro = this.intro;\n    chunk.outro = this.outro;\n    chunk.content = this.content;\n    chunk.storeName = this.storeName;\n    chunk.edited = this.edited;\n    return chunk;\n  }\n  contains(index) {\n    return this.start < index && index < this.end;\n  }\n  eachNext(fn) {\n    let chunk = this;\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.next;\n    }\n  }\n  eachPrevious(fn) {\n    let chunk = this;\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.previous;\n    }\n  }\n  edit(content, storeName, contentOnly) {\n    this.content = content;\n    if (!contentOnly) {\n      this.intro = '';\n      this.outro = '';\n    }\n    this.storeName = storeName;\n    this.edited = true;\n    return this;\n  }\n  prependLeft(content) {\n    this.outro = content + this.outro;\n  }\n  prependRight(content) {\n    this.intro = content + this.intro;\n  }\n  reset() {\n    this.intro = '';\n    this.outro = '';\n    if (this.edited) {\n      this.content = this.original;\n      this.storeName = false;\n      this.edited = false;\n    }\n  }\n  split(index) {\n    const sliceIndex = index - this.start;\n    const originalBefore = this.original.slice(0, sliceIndex);\n    const originalAfter = this.original.slice(sliceIndex);\n    this.original = originalBefore;\n    const newChunk = new Chunk(index, this.end, originalAfter);\n    newChunk.outro = this.outro;\n    this.outro = '';\n    this.end = index;\n    if (this.edited) {\n      // after split we should save the edit content record into the correct chunk\n      // to make sure sourcemap correct\n      // For example:\n      // '  test'.trim()\n      //     split   -> '  ' + 'test'\n      //   ✔️ edit    -> '' + 'test'\n      //   ✖️ edit    -> 'test' + ''\n      // TODO is this block necessary?...\n      newChunk.edit('', false);\n      this.content = '';\n    } else {\n      this.content = originalBefore;\n    }\n    newChunk.next = this.next;\n    if (newChunk.next) newChunk.next.previous = newChunk;\n    newChunk.previous = this;\n    this.next = newChunk;\n    return newChunk;\n  }\n  toString() {\n    return this.intro + this.content + this.outro;\n  }\n  trimEnd(rx) {\n    this.outro = this.outro.replace(rx, '');\n    if (this.outro.length) return true;\n    const trimmed = this.content.replace(rx, '');\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        this.split(this.start + trimmed.length).edit('', undefined, true);\n        if (this.edited) {\n          // save the change, if it has been edited\n          this.edit(trimmed, this.storeName, true);\n        }\n      }\n      return true;\n    } else {\n      this.edit('', undefined, true);\n      this.intro = this.intro.replace(rx, '');\n      if (this.intro.length) return true;\n    }\n  }\n  trimStart(rx) {\n    this.intro = this.intro.replace(rx, '');\n    if (this.intro.length) return true;\n    const trimmed = this.content.replace(rx, '');\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        const newChunk = this.split(this.end - trimmed.length);\n        if (this.edited) {\n          // save the change, if it has been edited\n          newChunk.edit(trimmed, this.storeName, true);\n        }\n        this.edit('', undefined, true);\n      }\n      return true;\n    } else {\n      this.edit('', undefined, true);\n      this.outro = this.outro.replace(rx, '');\n      if (this.outro.length) return true;\n    }\n  }\n}\nfunction getBtoa() {\n  if (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {\n    return str => globalThis.btoa(unescape(encodeURIComponent(str)));\n  } else if (typeof Buffer === 'function') {\n    return str => Buffer.from(str, 'utf-8').toString('base64');\n  } else {\n    return () => {\n      throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n    };\n  }\n}\nconst btoa = /*#__PURE__*/getBtoa();\nclass SourceMap {\n  constructor(properties) {\n    this.version = 3;\n    this.file = properties.file;\n    this.sources = properties.sources;\n    this.sourcesContent = properties.sourcesContent;\n    this.names = properties.names;\n    this.mappings = encode(properties.mappings);\n    if (typeof properties.x_google_ignoreList !== 'undefined') {\n      this.x_google_ignoreList = properties.x_google_ignoreList;\n    }\n    if (typeof properties.debugId !== 'undefined') {\n      this.debugId = properties.debugId;\n    }\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  toUrl() {\n    return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n  }\n}\nfunction guessIndent(code) {\n  const lines = code.split('\\n');\n  const tabbed = lines.filter(line => /^\\t+/.test(line));\n  const spaced = lines.filter(line => /^ {2,}/.test(line));\n  if (tabbed.length === 0 && spaced.length === 0) {\n    return null;\n  }\n\n  // More lines tabbed than spaced? Assume tabs, and\n  // default to tabs in the case of a tie (or nothing\n  // to go on)\n  if (tabbed.length >= spaced.length) {\n    return '\\t';\n  }\n\n  // Otherwise, we need to guess the multiple\n  const min = spaced.reduce((previous, current) => {\n    const numSpaces = /^ +/.exec(current)[0].length;\n    return Math.min(numSpaces, previous);\n  }, Infinity);\n  return new Array(min + 1).join(' ');\n}\nfunction getRelativePath(from, to) {\n  const fromParts = from.split(/[/\\\\]/);\n  const toParts = to.split(/[/\\\\]/);\n  fromParts.pop(); // get dirname\n\n  while (fromParts[0] === toParts[0]) {\n    fromParts.shift();\n    toParts.shift();\n  }\n  if (fromParts.length) {\n    let i = fromParts.length;\n    while (i--) fromParts[i] = '..';\n  }\n  return fromParts.concat(toParts).join('/');\n}\nconst toString = Object.prototype.toString;\nfunction isObject(thing) {\n  return toString.call(thing) === '[object Object]';\n}\nfunction getLocator(source) {\n  const originalLines = source.split('\\n');\n  const lineOffsets = [];\n  for (let i = 0, pos = 0; i < originalLines.length; i++) {\n    lineOffsets.push(pos);\n    pos += originalLines[i].length + 1;\n  }\n  return function locate(index) {\n    let i = 0;\n    let j = lineOffsets.length;\n    while (i < j) {\n      const m = i + j >> 1;\n      if (index < lineOffsets[m]) {\n        j = m;\n      } else {\n        i = m + 1;\n      }\n    }\n    const line = i - 1;\n    const column = index - lineOffsets[line];\n    return {\n      line,\n      column\n    };\n  };\n}\nconst wordRegex = /\\w/;\nclass Mappings {\n  constructor(hires) {\n    this.hires = hires;\n    this.generatedCodeLine = 0;\n    this.generatedCodeColumn = 0;\n    this.raw = [];\n    this.rawSegments = this.raw[this.generatedCodeLine] = [];\n    this.pending = null;\n  }\n  addEdit(sourceIndex, content, loc, nameIndex) {\n    if (content.length) {\n      const contentLengthMinusOne = content.length - 1;\n      let contentLineEnd = content.indexOf('\\n', 0);\n      let previousContentLineEnd = -1;\n      // Loop through each line in the content and add a segment, but stop if the last line is empty,\n      // else code afterwards would fill one line too many\n      while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n        const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n        if (nameIndex >= 0) {\n          segment.push(nameIndex);\n        }\n        this.rawSegments.push(segment);\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        previousContentLineEnd = contentLineEnd;\n        contentLineEnd = content.indexOf('\\n', contentLineEnd + 1);\n      }\n      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n      if (nameIndex >= 0) {\n        segment.push(nameIndex);\n      }\n      this.rawSegments.push(segment);\n      this.advance(content.slice(previousContentLineEnd + 1));\n    } else if (this.pending) {\n      this.rawSegments.push(this.pending);\n      this.advance(content);\n    }\n    this.pending = null;\n  }\n  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n    let originalCharIndex = chunk.start;\n    let first = true;\n    // when iterating each char, check if it's in a word boundary\n    let charInHiresBoundary = false;\n    while (originalCharIndex < chunk.end) {\n      if (original[originalCharIndex] === '\\n') {\n        loc.line += 1;\n        loc.column = 0;\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        first = true;\n        charInHiresBoundary = false;\n      } else {\n        if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n          const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n          if (this.hires === 'boundary') {\n            // in hires \"boundary\", group segments per word boundary than per char\n            if (wordRegex.test(original[originalCharIndex])) {\n              // for first char in the boundary found, start the boundary by pushing a segment\n              if (!charInHiresBoundary) {\n                this.rawSegments.push(segment);\n                charInHiresBoundary = true;\n              }\n            } else {\n              // for non-word char, end the boundary by pushing a segment\n              this.rawSegments.push(segment);\n              charInHiresBoundary = false;\n            }\n          } else {\n            this.rawSegments.push(segment);\n          }\n        }\n        loc.column += 1;\n        this.generatedCodeColumn += 1;\n        first = false;\n      }\n      originalCharIndex += 1;\n    }\n    this.pending = null;\n  }\n  advance(str) {\n    if (!str) return;\n    const lines = str.split('\\n');\n    if (lines.length > 1) {\n      for (let i = 0; i < lines.length - 1; i++) {\n        this.generatedCodeLine++;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n      }\n      this.generatedCodeColumn = 0;\n    }\n    this.generatedCodeColumn += lines[lines.length - 1].length;\n  }\n}\nconst n = '\\n';\nconst warned = {\n  insertLeft: false,\n  insertRight: false,\n  storeName: false\n};\nclass MagicString {\n  constructor(string, options = {}) {\n    const chunk = new Chunk(0, string.length, string);\n    Object.defineProperties(this, {\n      original: {\n        writable: true,\n        value: string\n      },\n      outro: {\n        writable: true,\n        value: ''\n      },\n      intro: {\n        writable: true,\n        value: ''\n      },\n      firstChunk: {\n        writable: true,\n        value: chunk\n      },\n      lastChunk: {\n        writable: true,\n        value: chunk\n      },\n      lastSearchedChunk: {\n        writable: true,\n        value: chunk\n      },\n      byStart: {\n        writable: true,\n        value: {}\n      },\n      byEnd: {\n        writable: true,\n        value: {}\n      },\n      filename: {\n        writable: true,\n        value: options.filename\n      },\n      indentExclusionRanges: {\n        writable: true,\n        value: options.indentExclusionRanges\n      },\n      sourcemapLocations: {\n        writable: true,\n        value: new BitSet()\n      },\n      storedNames: {\n        writable: true,\n        value: {}\n      },\n      indentStr: {\n        writable: true,\n        value: undefined\n      },\n      ignoreList: {\n        writable: true,\n        value: options.ignoreList\n      },\n      offset: {\n        writable: true,\n        value: options.offset || 0\n      }\n    });\n    this.byStart[0] = chunk;\n    this.byEnd[string.length] = chunk;\n  }\n  addSourcemapLocation(char) {\n    this.sourcemapLocations.add(char);\n  }\n  append(content) {\n    if (typeof content !== 'string') throw new TypeError('outro content must be a string');\n    this.outro += content;\n    return this;\n  }\n  appendLeft(index, content) {\n    index = index + this.offset;\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n    this._split(index);\n    const chunk = this.byEnd[index];\n    if (chunk) {\n      chunk.appendLeft(content);\n    } else {\n      this.intro += content;\n    }\n    return this;\n  }\n  appendRight(index, content) {\n    index = index + this.offset;\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n    this._split(index);\n    const chunk = this.byStart[index];\n    if (chunk) {\n      chunk.appendRight(content);\n    } else {\n      this.outro += content;\n    }\n    return this;\n  }\n  clone() {\n    const cloned = new MagicString(this.original, {\n      filename: this.filename,\n      offset: this.offset\n    });\n    let originalChunk = this.firstChunk;\n    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n    while (originalChunk) {\n      cloned.byStart[clonedChunk.start] = clonedChunk;\n      cloned.byEnd[clonedChunk.end] = clonedChunk;\n      const nextOriginalChunk = originalChunk.next;\n      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n      if (nextClonedChunk) {\n        clonedChunk.next = nextClonedChunk;\n        nextClonedChunk.previous = clonedChunk;\n        clonedChunk = nextClonedChunk;\n      }\n      originalChunk = nextOriginalChunk;\n    }\n    cloned.lastChunk = clonedChunk;\n    if (this.indentExclusionRanges) {\n      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n    }\n    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n    cloned.intro = this.intro;\n    cloned.outro = this.outro;\n    return cloned;\n  }\n  generateDecodedMap(options) {\n    options = options || {};\n    const sourceIndex = 0;\n    const names = Object.keys(this.storedNames);\n    const mappings = new Mappings(options.hires);\n    const locate = getLocator(this.original);\n    if (this.intro) {\n      mappings.advance(this.intro);\n    }\n    this.firstChunk.eachNext(chunk => {\n      const loc = locate(chunk.start);\n      if (chunk.intro.length) mappings.advance(chunk.intro);\n      if (chunk.edited) {\n        mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n      } else {\n        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n      }\n      if (chunk.outro.length) mappings.advance(chunk.outro);\n    });\n    return {\n      file: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n      sources: [options.source ? getRelativePath(options.file || '', options.source) : options.file || ''],\n      sourcesContent: options.includeContent ? [this.original] : undefined,\n      names,\n      mappings: mappings.raw,\n      x_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined\n    };\n  }\n  generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n  }\n  _ensureindentStr() {\n    if (this.indentStr === undefined) {\n      this.indentStr = guessIndent(this.original);\n    }\n  }\n  _getRawIndentString() {\n    this._ensureindentStr();\n    return this.indentStr;\n  }\n  getIndentString() {\n    this._ensureindentStr();\n    return this.indentStr === null ? '\\t' : this.indentStr;\n  }\n  indent(indentStr, options) {\n    const pattern = /^[^\\r\\n]/gm;\n    if (isObject(indentStr)) {\n      options = indentStr;\n      indentStr = undefined;\n    }\n    if (indentStr === undefined) {\n      this._ensureindentStr();\n      indentStr = this.indentStr || '\\t';\n    }\n    if (indentStr === '') return this; // noop\n\n    options = options || {};\n\n    // Process exclusion ranges\n    const isExcluded = {};\n    if (options.exclude) {\n      const exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n      exclusions.forEach(exclusion => {\n        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n          isExcluded[i] = true;\n        }\n      });\n    }\n    let shouldIndentNextCharacter = options.indentStart !== false;\n    const replacer = match => {\n      if (shouldIndentNextCharacter) return `${indentStr}${match}`;\n      shouldIndentNextCharacter = true;\n      return match;\n    };\n    this.intro = this.intro.replace(pattern, replacer);\n    let charIndex = 0;\n    let chunk = this.firstChunk;\n    while (chunk) {\n      const end = chunk.end;\n      if (chunk.edited) {\n        if (!isExcluded[charIndex]) {\n          chunk.content = chunk.content.replace(pattern, replacer);\n          if (chunk.content.length) {\n            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n          }\n        }\n      } else {\n        charIndex = chunk.start;\n        while (charIndex < end) {\n          if (!isExcluded[charIndex]) {\n            const char = this.original[charIndex];\n            if (char === '\\n') {\n              shouldIndentNextCharacter = true;\n            } else if (char !== '\\r' && shouldIndentNextCharacter) {\n              shouldIndentNextCharacter = false;\n              if (charIndex === chunk.start) {\n                chunk.prependRight(indentStr);\n              } else {\n                this._splitChunk(chunk, charIndex);\n                chunk = chunk.next;\n                chunk.prependRight(indentStr);\n              }\n            }\n          }\n          charIndex += 1;\n        }\n      }\n      charIndex = chunk.end;\n      chunk = chunk.next;\n    }\n    this.outro = this.outro.replace(pattern, replacer);\n    return this;\n  }\n  insert() {\n    throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n  }\n  insertLeft(index, content) {\n    if (!warned.insertLeft) {\n      console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead');\n      warned.insertLeft = true;\n    }\n    return this.appendLeft(index, content);\n  }\n  insertRight(index, content) {\n    if (!warned.insertRight) {\n      console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead');\n      warned.insertRight = true;\n    }\n    return this.prependRight(index, content);\n  }\n  move(start, end, index) {\n    start = start + this.offset;\n    end = end + this.offset;\n    index = index + this.offset;\n    if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n    this._split(start);\n    this._split(end);\n    this._split(index);\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    const oldLeft = first.previous;\n    const oldRight = last.next;\n    const newRight = this.byStart[index];\n    if (!newRight && last === this.lastChunk) return this;\n    const newLeft = newRight ? newRight.previous : this.lastChunk;\n    if (oldLeft) oldLeft.next = oldRight;\n    if (oldRight) oldRight.previous = oldLeft;\n    if (newLeft) newLeft.next = first;\n    if (newRight) newRight.previous = last;\n    if (!first.previous) this.firstChunk = last.next;\n    if (!last.next) {\n      this.lastChunk = first.previous;\n      this.lastChunk.next = null;\n    }\n    first.previous = newLeft;\n    last.next = newRight || null;\n    if (!newLeft) this.firstChunk = first;\n    if (!newRight) this.lastChunk = last;\n    return this;\n  }\n  overwrite(start, end, content, options) {\n    options = options || {};\n    return this.update(start, end, content, {\n      ...options,\n      overwrite: !options.contentOnly\n    });\n  }\n  update(start, end, content, options) {\n    start = start + this.offset;\n    end = end + this.offset;\n    if (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (end > this.original.length) throw new Error('end is out of bounds');\n    if (start === end) throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');\n    this._split(start);\n    this._split(end);\n    if (options === true) {\n      if (!warned.storeName) {\n        console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string');\n        warned.storeName = true;\n      }\n      options = {\n        storeName: true\n      };\n    }\n    const storeName = options !== undefined ? options.storeName : false;\n    const overwrite = options !== undefined ? options.overwrite : false;\n    if (storeName) {\n      const original = this.original.slice(start, end);\n      Object.defineProperty(this.storedNames, original, {\n        writable: true,\n        value: true,\n        enumerable: true\n      });\n    }\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    if (first) {\n      let chunk = first;\n      while (chunk !== last) {\n        if (chunk.next !== this.byStart[chunk.end]) {\n          throw new Error('Cannot overwrite across a split point');\n        }\n        chunk = chunk.next;\n        chunk.edit('', false);\n      }\n      first.edit(content, storeName, !overwrite);\n    } else {\n      // must be inserting at the end\n      const newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n      // TODO last chunk in the array may not be the last chunk, if it's moved...\n      last.next = newChunk;\n      newChunk.previous = last;\n    }\n    return this;\n  }\n  prepend(content) {\n    if (typeof content !== 'string') throw new TypeError('outro content must be a string');\n    this.intro = content + this.intro;\n    return this;\n  }\n  prependLeft(index, content) {\n    index = index + this.offset;\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n    this._split(index);\n    const chunk = this.byEnd[index];\n    if (chunk) {\n      chunk.prependLeft(content);\n    } else {\n      this.intro = content + this.intro;\n    }\n    return this;\n  }\n  prependRight(index, content) {\n    index = index + this.offset;\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n    this._split(index);\n    const chunk = this.byStart[index];\n    if (chunk) {\n      chunk.prependRight(content);\n    } else {\n      this.outro = content + this.outro;\n    }\n    return this;\n  }\n  remove(start, end) {\n    start = start + this.offset;\n    end = end + this.offset;\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (start === end) return this;\n    if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n    if (start > end) throw new Error('end must be greater than start');\n    this._split(start);\n    this._split(end);\n    let chunk = this.byStart[start];\n    while (chunk) {\n      chunk.intro = '';\n      chunk.outro = '';\n      chunk.edit('');\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n    return this;\n  }\n  reset(start, end) {\n    start = start + this.offset;\n    end = end + this.offset;\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (start === end) return this;\n    if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n    if (start > end) throw new Error('end must be greater than start');\n    this._split(start);\n    this._split(end);\n    let chunk = this.byStart[start];\n    while (chunk) {\n      chunk.reset();\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n    return this;\n  }\n  lastChar() {\n    if (this.outro.length) return this.outro[this.outro.length - 1];\n    let chunk = this.lastChunk;\n    do {\n      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n      if (chunk.content.length) return chunk.content[chunk.content.length - 1];\n      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n    } while (chunk = chunk.previous);\n    if (this.intro.length) return this.intro[this.intro.length - 1];\n    return '';\n  }\n  lastLine() {\n    let lineIndex = this.outro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n    let lineStr = this.outro;\n    let chunk = this.lastChunk;\n    do {\n      if (chunk.outro.length > 0) {\n        lineIndex = chunk.outro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.outro + lineStr;\n      }\n      if (chunk.content.length > 0) {\n        lineIndex = chunk.content.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.content + lineStr;\n      }\n      if (chunk.intro.length > 0) {\n        lineIndex = chunk.intro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.intro + lineStr;\n      }\n    } while (chunk = chunk.previous);\n    lineIndex = this.intro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n    return this.intro + lineStr;\n  }\n  slice(start = 0, end = this.original.length - this.offset) {\n    start = start + this.offset;\n    end = end + this.offset;\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    let result = '';\n\n    // find start chunk\n    let chunk = this.firstChunk;\n    while (chunk && (chunk.start > start || chunk.end <= start)) {\n      // found end chunk before start\n      if (chunk.start < end && chunk.end >= end) {\n        return result;\n      }\n      chunk = chunk.next;\n    }\n    if (chunk && chunk.edited && chunk.start !== start) throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n    const startChunk = chunk;\n    while (chunk) {\n      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n        result += chunk.intro;\n      }\n      const containsEnd = chunk.start < end && chunk.end >= end;\n      if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n      const sliceStart = startChunk === chunk ? start - chunk.start : 0;\n      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n      result += chunk.content.slice(sliceStart, sliceEnd);\n      if (chunk.outro && (!containsEnd || chunk.end === end)) {\n        result += chunk.outro;\n      }\n      if (containsEnd) {\n        break;\n      }\n      chunk = chunk.next;\n    }\n    return result;\n  }\n\n  // TODO deprecate this? not really very useful\n  snip(start, end) {\n    const clone = this.clone();\n    clone.remove(0, start);\n    clone.remove(end, clone.original.length);\n    return clone;\n  }\n  _split(index) {\n    if (this.byStart[index] || this.byEnd[index]) return;\n    let chunk = this.lastSearchedChunk;\n    let previousChunk = chunk;\n    const searchForward = index > chunk.end;\n    while (chunk) {\n      if (chunk.contains(index)) return this._splitChunk(chunk, index);\n      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\n      // Prevent infinite loop (e.g. via empty chunks, where start === end)\n      if (chunk === previousChunk) return;\n      previousChunk = chunk;\n    }\n  }\n  _splitChunk(chunk, index) {\n    if (chunk.edited && chunk.content.length) {\n      // zero-length edited chunks are a special case (overlapping replacements)\n      const loc = getLocator(this.original)(index);\n      throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`);\n    }\n    const newChunk = chunk.split(index);\n    this.byEnd[index] = chunk;\n    this.byStart[index] = newChunk;\n    this.byEnd[newChunk.end] = newChunk;\n    if (chunk === this.lastChunk) this.lastChunk = newChunk;\n    this.lastSearchedChunk = chunk;\n    return true;\n  }\n  toString() {\n    let str = this.intro;\n    let chunk = this.firstChunk;\n    while (chunk) {\n      str += chunk.toString();\n      chunk = chunk.next;\n    }\n    return str + this.outro;\n  }\n  isEmpty() {\n    let chunk = this.firstChunk;\n    do {\n      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;\n    } while (chunk = chunk.next);\n    return true;\n  }\n  length() {\n    let chunk = this.firstChunk;\n    let length = 0;\n    do {\n      length += chunk.intro.length + chunk.content.length + chunk.outro.length;\n    } while (chunk = chunk.next);\n    return length;\n  }\n  trimLines() {\n    return this.trim('[\\\\r\\\\n]');\n  }\n  trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n  }\n  trimEndAborted(charType) {\n    const rx = new RegExp((charType || '\\\\s') + '+$');\n    this.outro = this.outro.replace(rx, '');\n    if (this.outro.length) return true;\n    let chunk = this.lastChunk;\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimEnd(rx);\n\n      // if chunk was trimmed, we have a new lastChunk\n      if (chunk.end !== end) {\n        if (this.lastChunk === chunk) {\n          this.lastChunk = chunk.next;\n        }\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n      if (aborted) return true;\n      chunk = chunk.previous;\n    } while (chunk);\n    return false;\n  }\n  trimEnd(charType) {\n    this.trimEndAborted(charType);\n    return this;\n  }\n  trimStartAborted(charType) {\n    const rx = new RegExp('^' + (charType || '\\\\s') + '+');\n    this.intro = this.intro.replace(rx, '');\n    if (this.intro.length) return true;\n    let chunk = this.firstChunk;\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimStart(rx);\n      if (chunk.end !== end) {\n        // special case...\n        if (chunk === this.lastChunk) this.lastChunk = chunk.next;\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n      if (aborted) return true;\n      chunk = chunk.next;\n    } while (chunk);\n    return false;\n  }\n  trimStart(charType) {\n    this.trimStartAborted(charType);\n    return this;\n  }\n  hasChanged() {\n    return this.original !== this.toString();\n  }\n  _replaceRegexp(searchValue, replacement) {\n    function getReplacement(match, str) {\n      if (typeof replacement === 'string') {\n        return replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n          if (i === '$') return '$';\n          if (i === '&') return match[0];\n          const num = +i;\n          if (num < match.length) return match[+i];\n          return `$${i}`;\n        });\n      } else {\n        return replacement(...match, match.index, str, match.groups);\n      }\n    }\n    function matchAll(re, str) {\n      let match;\n      const matches = [];\n      while (match = re.exec(str)) {\n        matches.push(match);\n      }\n      return matches;\n    }\n    if (searchValue.global) {\n      const matches = matchAll(searchValue, this.original);\n      matches.forEach(match => {\n        if (match.index != null) {\n          const replacement = getReplacement(match, this.original);\n          if (replacement !== match[0]) {\n            this.overwrite(match.index, match.index + match[0].length, replacement);\n          }\n        }\n      });\n    } else {\n      const match = this.original.match(searchValue);\n      if (match && match.index != null) {\n        const replacement = getReplacement(match, this.original);\n        if (replacement !== match[0]) {\n          this.overwrite(match.index, match.index + match[0].length, replacement);\n        }\n      }\n    }\n    return this;\n  }\n  _replaceString(string, replacement) {\n    const {\n      original\n    } = this;\n    const index = original.indexOf(string);\n    if (index !== -1) {\n      this.overwrite(index, index + string.length, replacement);\n    }\n    return this;\n  }\n  replace(searchValue, replacement) {\n    if (typeof searchValue === 'string') {\n      return this._replaceString(searchValue, replacement);\n    }\n    return this._replaceRegexp(searchValue, replacement);\n  }\n  _replaceAllString(string, replacement) {\n    const {\n      original\n    } = this;\n    const stringLength = string.length;\n    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {\n      const previous = original.slice(index, index + stringLength);\n      if (previous !== replacement) this.overwrite(index, index + stringLength, replacement);\n    }\n    return this;\n  }\n  replaceAll(searchValue, replacement) {\n    if (typeof searchValue === 'string') {\n      return this._replaceAllString(searchValue, replacement);\n    }\n    if (!searchValue.global) {\n      throw new TypeError('MagicString.prototype.replaceAll called with a non-global RegExp argument');\n    }\n    return this._replaceRegexp(searchValue, replacement);\n  }\n}\nconst hasOwnProp = Object.prototype.hasOwnProperty;\nclass Bundle {\n  constructor(options = {}) {\n    this.intro = options.intro || '';\n    this.separator = options.separator !== undefined ? options.separator : '\\n';\n    this.sources = [];\n    this.uniqueSources = [];\n    this.uniqueSourceIndexByFilename = {};\n  }\n  addSource(source) {\n    if (source instanceof MagicString) {\n      return this.addSource({\n        content: source,\n        filename: source.filename,\n        separator: this.separator\n      });\n    }\n    if (!isObject(source) || !source.content) {\n      throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n    }\n    ['filename', 'ignoreList', 'indentExclusionRanges', 'separator'].forEach(option => {\n      if (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n    });\n    if (source.separator === undefined) {\n      // TODO there's a bunch of this sort of thing, needs cleaning up\n      source.separator = this.separator;\n    }\n    if (source.filename) {\n      if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n        this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n        this.uniqueSources.push({\n          filename: source.filename,\n          content: source.content.original\n        });\n      } else {\n        const uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n        if (source.content.original !== uniqueSource.content) {\n          throw new Error(`Illegal source: same filename (${source.filename}), different contents`);\n        }\n      }\n    }\n    this.sources.push(source);\n    return this;\n  }\n  append(str, options) {\n    this.addSource({\n      content: new MagicString(str),\n      separator: options && options.separator || ''\n    });\n    return this;\n  }\n  clone() {\n    const bundle = new Bundle({\n      intro: this.intro,\n      separator: this.separator\n    });\n    this.sources.forEach(source => {\n      bundle.addSource({\n        filename: source.filename,\n        content: source.content.clone(),\n        separator: source.separator\n      });\n    });\n    return bundle;\n  }\n  generateDecodedMap(options = {}) {\n    const names = [];\n    let x_google_ignoreList = undefined;\n    this.sources.forEach(source => {\n      Object.keys(source.content.storedNames).forEach(name => {\n        if (!~names.indexOf(name)) names.push(name);\n      });\n    });\n    const mappings = new Mappings(options.hires);\n    if (this.intro) {\n      mappings.advance(this.intro);\n    }\n    this.sources.forEach((source, i) => {\n      if (i > 0) {\n        mappings.advance(this.separator);\n      }\n      const sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n      const magicString = source.content;\n      const locate = getLocator(magicString.original);\n      if (magicString.intro) {\n        mappings.advance(magicString.intro);\n      }\n      magicString.firstChunk.eachNext(chunk => {\n        const loc = locate(chunk.start);\n        if (chunk.intro.length) mappings.advance(chunk.intro);\n        if (source.filename) {\n          if (chunk.edited) {\n            mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n          } else {\n            mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);\n          }\n        } else {\n          mappings.advance(chunk.content);\n        }\n        if (chunk.outro.length) mappings.advance(chunk.outro);\n      });\n      if (magicString.outro) {\n        mappings.advance(magicString.outro);\n      }\n      if (source.ignoreList && sourceIndex !== -1) {\n        if (x_google_ignoreList === undefined) {\n          x_google_ignoreList = [];\n        }\n        x_google_ignoreList.push(sourceIndex);\n      }\n    });\n    return {\n      file: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n      sources: this.uniqueSources.map(source => {\n        return options.file ? getRelativePath(options.file, source.filename) : source.filename;\n      }),\n      sourcesContent: this.uniqueSources.map(source => {\n        return options.includeContent ? source.content : null;\n      }),\n      names,\n      mappings: mappings.raw,\n      x_google_ignoreList\n    };\n  }\n  generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n  }\n  getIndentString() {\n    const indentStringCounts = {};\n    this.sources.forEach(source => {\n      const indentStr = source.content._getRawIndentString();\n      if (indentStr === null) return;\n      if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n      indentStringCounts[indentStr] += 1;\n    });\n    return Object.keys(indentStringCounts).sort((a, b) => {\n      return indentStringCounts[a] - indentStringCounts[b];\n    })[0] || '\\t';\n  }\n  indent(indentStr) {\n    if (!arguments.length) {\n      indentStr = this.getIndentString();\n    }\n    if (indentStr === '') return this; // noop\n\n    let trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n    this.sources.forEach((source, i) => {\n      const separator = source.separator !== undefined ? source.separator : this.separator;\n      const indentStart = trailingNewline || i > 0 && /\\r?\\n$/.test(separator);\n      source.content.indent(indentStr, {\n        exclude: source.indentExclusionRanges,\n        indentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n      });\n      trailingNewline = source.content.lastChar() === '\\n';\n    });\n    if (this.intro) {\n      this.intro = indentStr + this.intro.replace(/^[^\\n]/gm, (match, index) => {\n        return index > 0 ? indentStr + match : match;\n      });\n    }\n    return this;\n  }\n  prepend(str) {\n    this.intro = str + this.intro;\n    return this;\n  }\n  toString() {\n    const body = this.sources.map((source, i) => {\n      const separator = source.separator !== undefined ? source.separator : this.separator;\n      const str = (i > 0 ? separator : '') + source.content.toString();\n      return str;\n    }).join('');\n    return this.intro + body;\n  }\n  isEmpty() {\n    if (this.intro.length && this.intro.trim()) return false;\n    if (this.sources.some(source => !source.content.isEmpty())) return false;\n    return true;\n  }\n  length() {\n    return this.sources.reduce((length, source) => length + source.content.length(), this.intro.length);\n  }\n  trimLines() {\n    return this.trim('[\\\\r\\\\n]');\n  }\n  trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n  }\n  trimStart(charType) {\n    const rx = new RegExp('^' + (charType || '\\\\s') + '+');\n    this.intro = this.intro.replace(rx, '');\n    if (!this.intro) {\n      let source;\n      let i = 0;\n      do {\n        source = this.sources[i++];\n        if (!source) {\n          break;\n        }\n      } while (!source.content.trimStartAborted(charType));\n    }\n    return this;\n  }\n  trimEnd(charType) {\n    const rx = new RegExp((charType || '\\\\s') + '+$');\n    let source;\n    let i = this.sources.length - 1;\n    do {\n      source = this.sources[i--];\n      if (!source) {\n        this.intro = this.intro.replace(rx, '');\n        break;\n      }\n    } while (!source.content.trimEndAborted(charType));\n    return this;\n  }\n}\nexport { Bundle, SourceMap, MagicString as default };","map":{"version":3,"names":["BitSet","constructor","arg","bits","slice","add","n","has","Chunk","start","end","content","original","intro","outro","storeName","edited","previous","next","appendLeft","appendRight","clone","chunk","contains","index","eachNext","fn","eachPrevious","edit","contentOnly","prependLeft","prependRight","reset","split","sliceIndex","originalBefore","originalAfter","newChunk","toString","trimEnd","rx","replace","length","trimmed","undefined","trimStart","getBtoa","globalThis","btoa","str","unescape","encodeURIComponent","Buffer","from","Error","SourceMap","properties","version","file","sources","sourcesContent","names","mappings","encode","x_google_ignoreList","debugId","JSON","stringify","toUrl","guessIndent","code","lines","tabbed","filter","line","test","spaced","min","reduce","current","numSpaces","exec","Math","Infinity","Array","join","getRelativePath","to","fromParts","toParts","pop","shift","i","concat","Object","prototype","isObject","thing","call","getLocator","source","originalLines","lineOffsets","pos","push","locate","j","m","column","wordRegex","Mappings","hires","generatedCodeLine","generatedCodeColumn","raw","rawSegments","pending","addEdit","sourceIndex","loc","nameIndex","contentLengthMinusOne","contentLineEnd","indexOf","previousContentLineEnd","segment","advance","addUneditedChunk","sourcemapLocations","originalCharIndex","first","charInHiresBoundary","warned","insertLeft","insertRight","MagicString","string","options","defineProperties","writable","value","firstChunk","lastChunk","lastSearchedChunk","byStart","byEnd","filename","indentExclusionRanges","storedNames","indentStr","ignoreList","offset","addSourcemapLocation","char","append","TypeError","_split","cloned","originalChunk","clonedChunk","nextOriginalChunk","nextClonedChunk","generateDecodedMap","keys","includeContent","generateMap","_ensureindentStr","_getRawIndentString","getIndentString","indent","pattern","isExcluded","exclude","exclusions","forEach","exclusion","shouldIndentNextCharacter","indentStart","replacer","match","charIndex","_splitChunk","insert","console","warn","move","last","oldLeft","oldRight","newRight","newLeft","overwrite","update","defineProperty","enumerable","prepend","remove","lastChar","lastLine","lineIndex","lastIndexOf","substr","lineStr","result","startChunk","containsEnd","sliceStart","sliceEnd","snip","previousChunk","searchForward","isEmpty","trim","trimLines","charType","trimEndAborted","RegExp","aborted","trimStartAborted","hasChanged","_replaceRegexp","searchValue","replacement","getReplacement","_","num","groups","matchAll","re","matches","global","_replaceString","_replaceAllString","stringLength","replaceAll","hasOwnProp","hasOwnProperty","Bundle","separator","uniqueSources","uniqueSourceIndexByFilename","addSource","option","uniqueSource","bundle","name","magicString","map","indentStringCounts","sort","a","b","arguments","trailingNewline","body","some"],"sources":["C:\\Users\\dah03\\calendar\\mycalendar\\node_modules\\@tailwindcss\\node\\node_modules\\magic-string\\src\\BitSet.js","C:\\Users\\dah03\\calendar\\mycalendar\\node_modules\\@tailwindcss\\node\\node_modules\\magic-string\\src\\Chunk.js","C:\\Users\\dah03\\calendar\\mycalendar\\node_modules\\@tailwindcss\\node\\node_modules\\magic-string\\src\\SourceMap.js","C:\\Users\\dah03\\calendar\\mycalendar\\node_modules\\@tailwindcss\\node\\node_modules\\magic-string\\src\\utils\\guessIndent.js","C:\\Users\\dah03\\calendar\\mycalendar\\node_modules\\@tailwindcss\\node\\node_modules\\magic-string\\src\\utils\\getRelativePath.js","C:\\Users\\dah03\\calendar\\mycalendar\\node_modules\\@tailwindcss\\node\\node_modules\\magic-string\\src\\utils\\isObject.js","C:\\Users\\dah03\\calendar\\mycalendar\\node_modules\\@tailwindcss\\node\\node_modules\\magic-string\\src\\utils\\getLocator.js","C:\\Users\\dah03\\calendar\\mycalendar\\node_modules\\@tailwindcss\\node\\node_modules\\magic-string\\src\\utils\\Mappings.js","C:\\Users\\dah03\\calendar\\mycalendar\\node_modules\\@tailwindcss\\node\\node_modules\\magic-string\\src\\MagicString.js","C:\\Users\\dah03\\calendar\\mycalendar\\node_modules\\@tailwindcss\\node\\node_modules\\magic-string\\src\\Bundle.js"],"sourcesContent":["export default class BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n","export default class Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\tif (DEBUG) {\n\t\t\t// we make these non-enumerable, for sanity while debugging\n\t\t\tObject.defineProperties(this, {\n\t\t\t\tprevious: { writable: true, value: null },\n\t\t\t\tnext: { writable: true, value: null },\n\t\t\t});\n\t\t} else {\n\t\t\tthis.previous = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\treset() {\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\t\tif (this.edited) {\n\t\t\tthis.content = this.original;\n\t\t\tthis.storeName = false;\n\t\t\tthis.edited = false;\n\t\t}\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// after split we should save the edit content record into the correct chunk\n\t\t\t// to make sure sourcemap correct\n\t\t\t// For example:\n\t\t\t// '  test'.trim()\n\t\t\t//     split   -> '  ' + 'test'\n\t\t\t//   ✔️ edit    -> '' + 'test'\n\t\t\t//   ✖️ edit    -> 'test' + ''\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tthis.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tconst newChunk = this.split(this.end - trimmed.length);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tnewChunk.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n","import { encode } from '@jridgewell/sourcemap-codec';\n\nfunction getBtoa() {\n\tif (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {\n\t\treturn (str) => globalThis.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t} else {\n\t\treturn () => {\n\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t};\n\t}\n}\n\nconst btoa = /*#__PURE__*/ getBtoa();\n\nexport default class SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t\tif (typeof properties.x_google_ignoreList !== 'undefined') {\n\t\t\tthis.x_google_ignoreList = properties.x_google_ignoreList;\n\t\t}\n\t\tif (typeof properties.debugId !== 'undefined') {\n\t\t\tthis.debugId = properties.debugId;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n","export default function guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n","export default function getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n","const toString = Object.prototype.toString;\n\nexport default function isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n","export default function getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n","const wordRegex = /\\w/;\n\nexport default class Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst contentLengthMinusOne = content.length - 1;\n\t\t\tlet contentLineEnd = content.indexOf('\\n', 0);\n\t\t\tlet previousContentLineEnd = -1;\n\t\t\t// Loop through each line in the content and add a segment, but stop if the last line is empty,\n\t\t\t// else code afterwards would fill one line too many\n\t\t\twhile (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\t\tif (nameIndex >= 0) {\n\t\t\t\t\tsegment.push(nameIndex);\n\t\t\t\t}\n\t\t\t\tthis.rawSegments.push(segment);\n\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\n\t\t\t\tpreviousContentLineEnd = contentLineEnd;\n\t\t\t\tcontentLineEnd = content.indexOf('\\n', contentLineEnd + 1);\n\t\t\t}\n\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\n\t\t\tthis.advance(content.slice(previousContentLineEnd + 1));\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t\tthis.advance(content);\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\t\t// when iterating each char, check if it's in a word boundary\n\t\tlet charInHiresBoundary = false;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t\tcharInHiresBoundary = false;\n\t\t\t} else {\n\t\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n\t\t\t\t\tif (this.hires === 'boundary') {\n\t\t\t\t\t\t// in hires \"boundary\", group segments per word boundary than per char\n\t\t\t\t\t\tif (wordRegex.test(original[originalCharIndex])) {\n\t\t\t\t\t\t\t// for first char in the boundary found, start the boundary by pushing a segment\n\t\t\t\t\t\t\tif (!charInHiresBoundary) {\n\t\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\t\tcharInHiresBoundary = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// for non-word char, end the boundary by pushing a segment\n\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\tcharInHiresBoundary = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n","import BitSet from './BitSet.js';\nimport Chunk from './Chunk.js';\nimport SourceMap from './SourceMap.js';\nimport guessIndent from './utils/guessIndent.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\nimport Stats from './utils/Stats.js';\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nexport default class MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: undefined },\n\t\t\tignoreList: { writable: true, value: options.ignoreList },\n\t\t\toffset: { writable: true, value: options.offset || 0 },\n\t\t});\n\n\t\tif (DEBUG) {\n\t\t\tObject.defineProperty(this, 'stats', { value: new Stats() });\n\t\t}\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendLeft');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendLeft');\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendRight');\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename, offset: this.offset });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: [\n\t\t\t\toptions.source ? getRelativePath(options.file || '', options.source) : options.file || '',\n\t\t\t],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : undefined,\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\t_ensureindentStr() {\n\t\tif (this.indentStr === undefined) {\n\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t}\n\t}\n\n\t_getRawIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr;\n\t}\n\n\tgetIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tif (indentStr === undefined) {\n\t\t\tthis._ensureindentStr();\n\t\t\tindentStr = this.indentStr || '\\t';\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',\n\t\t\t);\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',\n\t\t\t);\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\t\tindex = index + this.offset;\n\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tif (DEBUG) this.stats.time('move');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\n\t\tif (DEBUG) this.stats.timeEnd('move');\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\toptions = options || {};\n\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t}\n\n\tupdate(start, end, content, options) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',\n\t\t\t);\n\n\t\tif (DEBUG) this.stats.time('overwrite');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',\n\t\t\t\t);\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('overwrite');\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('remove');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('remove');\n\t\treturn this;\n\t}\n\n\treset(start, end) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('reset');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.reset();\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('reset');\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length - this.offset) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tif (DEBUG) this.stats.time('_split');\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tlet previousChunk = chunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\n\t\t\t// Prevent infinite loop (e.g. via empty chunks, where start === end)\n\t\t\tif (chunk === previousChunk) return;\n\n\t\t\tpreviousChunk = chunk;\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`,\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\tif (DEBUG) this.stats.timeEnd('_split');\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\t_replaceRegexp(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null) {\n\t\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\t\tthis.overwrite(match.index, match.index + match[0].length, replacement);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null) {\n\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\tthis.overwrite(match.index, match.index + match[0].length, replacement);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t_replaceString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst index = original.indexOf(string);\n\n\t\tif (index !== -1) {\n\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n\n\t_replaceAllString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst stringLength = string.length;\n\t\tfor (\n\t\t\tlet index = original.indexOf(string);\n\t\t\tindex !== -1;\n\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t) {\n\t\t\tconst previous = original.slice(index, index + stringLength);\n\t\t\tif (previous !== replacement) this.overwrite(index, index + stringLength, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplaceAll(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t}\n\n\t\tif (!searchValue.global) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument',\n\t\t\t);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n}\n","import MagicString from './MagicString.js';\nimport SourceMap from './SourceMap.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nexport default class Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`',\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'ignoreList', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tlet x_google_ignoreList = undefined;\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\n\t\t\tif (source.ignoreList && sourceIndex !== -1) {\n\t\t\t\tif (x_google_ignoreList === undefined) {\n\t\t\t\t\tx_google_ignoreList = [];\n\t\t\t\t}\n\t\t\t\tx_google_ignoreList.push(sourceIndex);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length,\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}