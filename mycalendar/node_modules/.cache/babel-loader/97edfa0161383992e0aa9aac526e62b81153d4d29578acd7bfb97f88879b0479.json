{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nconst forEachBail = require(\"./forEachBail\");\nconst {\n  processImportsField\n} = require(\"./util/entrypoints\");\nconst {\n  parseIdentifier\n} = require(\"./util/identifier\");\nconst {\n  deprecatedInvalidSegmentRegEx,\n  invalidSegmentRegEx\n} = require(\"./util/path\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").JsonObject} JsonObject */\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n/** @typedef {import(\"./util/entrypoints\").ImportsField} ImportsField */\n\nconst dotCode = \".\".charCodeAt(0);\nmodule.exports = class ImportsFieldPlugin {\n  /**\n   * @param {string | ResolveStepHook} source source\n   * @param {Set<string>} conditionNames condition names\n   * @param {string | string[]} fieldNamePath name path\n   * @param {string | ResolveStepHook} targetFile target file\n   * @param {string | ResolveStepHook} targetPackage target package\n   */\n  constructor(source, conditionNames, fieldNamePath, targetFile, targetPackage) {\n    this.source = source;\n    this.targetFile = targetFile;\n    this.targetPackage = targetPackage;\n    this.conditionNames = conditionNames;\n    this.fieldName = fieldNamePath;\n    /** @type {WeakMap<JsonObject, FieldProcessor>} */\n    this.fieldProcessorCache = new WeakMap();\n  }\n\n  /**\n   * @param {Resolver} resolver the resolver\n   * @returns {void}\n   */\n  apply(resolver) {\n    const targetFile = resolver.ensureHook(this.targetFile);\n    const targetPackage = resolver.ensureHook(this.targetPackage);\n    resolver.getHook(this.source).tapAsync(\"ImportsFieldPlugin\", (request, resolveContext, callback) => {\n      // When there is no description file, abort\n      if (!request.descriptionFilePath || request.request === undefined) {\n        return callback();\n      }\n      const remainingRequest = request.request + request.query + request.fragment;\n      const importsField = /** @type {ImportsField|null|undefined} */\n\n      DescriptionFileUtils.getField(/** @type {JsonObject} */request.descriptionFileData, this.fieldName);\n      if (!importsField) return callback();\n      if (request.directory) {\n        return callback(new Error(`Resolving to directories is not possible with the imports field (request was ${remainingRequest}/)`));\n      }\n\n      /** @type {string[]} */\n      let paths;\n      /** @type {string | null} */\n      let usedField;\n      try {\n        // We attach the cache to the description file instead of the importsField value\n        // because we use a WeakMap and the importsField could be a string too.\n        // Description file is always an object when exports field can be accessed.\n        let fieldProcessor = this.fieldProcessorCache.get(/** @type {JsonObject} */request.descriptionFileData);\n        if (fieldProcessor === undefined) {\n          fieldProcessor = processImportsField(importsField);\n          this.fieldProcessorCache.set(/** @type {JsonObject} */request.descriptionFileData, fieldProcessor);\n        }\n        [paths, usedField] = fieldProcessor(remainingRequest, this.conditionNames);\n      } catch (/** @type {unknown} */err) {\n        if (resolveContext.log) {\n          resolveContext.log(`Imports field in ${request.descriptionFilePath} can't be processed: ${err}`);\n        }\n        return callback(/** @type {Error} */err);\n      }\n      if (paths.length === 0) {\n        return callback(new Error(`Package import ${remainingRequest} is not imported from package ${request.descriptionFileRoot} (see imports field in ${request.descriptionFilePath})`));\n      }\n      forEachBail(paths,\n      /**\n       * @param {string} path path\n       * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback\n       * @param {number} i index\n       * @returns {void}\n       */\n      (path, callback, i) => {\n        const parsedIdentifier = parseIdentifier(path);\n        if (!parsedIdentifier) return callback();\n        const [path_, query, fragment] = parsedIdentifier;\n        switch (path_.charCodeAt(0)) {\n          // should be relative\n          case dotCode:\n            {\n              if (invalidSegmentRegEx.exec(path_.slice(2)) !== null && deprecatedInvalidSegmentRegEx.test(path_.slice(2)) !== null) {\n                if (paths.length === i) {\n                  return callback(new Error(`Invalid \"imports\" target \"${path}\" defined for \"${usedField}\" in the package config ${request.descriptionFilePath}, targets must start with \"./\"`));\n                }\n                return callback();\n              }\n\n              /** @type {ResolveRequest} */\n              const obj = {\n                ...request,\n                request: undefined,\n                path: resolver.join(/** @type {string} */request.descriptionFileRoot, path_),\n                relativePath: path_,\n                query,\n                fragment\n              };\n              resolver.doResolve(targetFile, obj, `using imports field: ${path}`, resolveContext, (err, result) => {\n                if (err) return callback(err);\n                // Don't allow to continue - https://github.com/webpack/enhanced-resolve/issues/400\n                if (result === undefined) return callback(null, null);\n                callback(null, result);\n              });\n              break;\n            }\n\n          // package resolving\n          default:\n            {\n              /** @type {ResolveRequest} */\n              const obj = {\n                ...request,\n                request: path_,\n                relativePath: path_,\n                fullySpecified: true,\n                query,\n                fragment\n              };\n              resolver.doResolve(targetPackage, obj, `using imports field: ${path}`, resolveContext, (err, result) => {\n                if (err) return callback(err);\n                // Don't allow to continue - https://github.com/webpack/enhanced-resolve/issues/400\n                if (result === undefined) return callback(null, null);\n                callback(null, result);\n              });\n            }\n        }\n      },\n      /**\n       * @param {(null|Error)=} err error\n       * @param {(null|ResolveRequest)=} result result\n       * @returns {void}\n       */\n      (err, result) => callback(err, result || null));\n    });\n  }\n};","map":{"version":3,"names":["DescriptionFileUtils","require","forEachBail","processImportsField","parseIdentifier","deprecatedInvalidSegmentRegEx","invalidSegmentRegEx","dotCode","charCodeAt","module","exports","ImportsFieldPlugin","constructor","source","conditionNames","fieldNamePath","targetFile","targetPackage","fieldName","fieldProcessorCache","WeakMap","apply","resolver","ensureHook","getHook","tapAsync","request","resolveContext","callback","descriptionFilePath","undefined","remainingRequest","query","fragment","importsField","getField","descriptionFileData","directory","Error","paths","usedField","fieldProcessor","get","set","err","log","length","descriptionFileRoot","path","i","parsedIdentifier","path_","exec","slice","test","obj","join","relativePath","doResolve","result","fullySpecified"],"sources":["C:/Users/dah03/calendar/mycalendar/node_modules/enhanced-resolve/lib/ImportsFieldPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nconst forEachBail = require(\"./forEachBail\");\nconst { processImportsField } = require(\"./util/entrypoints\");\nconst { parseIdentifier } = require(\"./util/identifier\");\nconst {\n\tdeprecatedInvalidSegmentRegEx,\n\tinvalidSegmentRegEx,\n} = require(\"./util/path\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").JsonObject} JsonObject */\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n/** @typedef {import(\"./util/entrypoints\").ImportsField} ImportsField */\n\nconst dotCode = \".\".charCodeAt(0);\n\nmodule.exports = class ImportsFieldPlugin {\n\t/**\n\t * @param {string | ResolveStepHook} source source\n\t * @param {Set<string>} conditionNames condition names\n\t * @param {string | string[]} fieldNamePath name path\n\t * @param {string | ResolveStepHook} targetFile target file\n\t * @param {string | ResolveStepHook} targetPackage target package\n\t */\n\tconstructor(\n\t\tsource,\n\t\tconditionNames,\n\t\tfieldNamePath,\n\t\ttargetFile,\n\t\ttargetPackage,\n\t) {\n\t\tthis.source = source;\n\t\tthis.targetFile = targetFile;\n\t\tthis.targetPackage = targetPackage;\n\t\tthis.conditionNames = conditionNames;\n\t\tthis.fieldName = fieldNamePath;\n\t\t/** @type {WeakMap<JsonObject, FieldProcessor>} */\n\t\tthis.fieldProcessorCache = new WeakMap();\n\t}\n\n\t/**\n\t * @param {Resolver} resolver the resolver\n\t * @returns {void}\n\t */\n\tapply(resolver) {\n\t\tconst targetFile = resolver.ensureHook(this.targetFile);\n\t\tconst targetPackage = resolver.ensureHook(this.targetPackage);\n\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ImportsFieldPlugin\", (request, resolveContext, callback) => {\n\t\t\t\t// When there is no description file, abort\n\t\t\t\tif (!request.descriptionFilePath || request.request === undefined) {\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\n\t\t\t\tconst remainingRequest =\n\t\t\t\t\trequest.request + request.query + request.fragment;\n\t\t\t\tconst importsField =\n\t\t\t\t\t/** @type {ImportsField|null|undefined} */\n\t\t\t\t\t(\n\t\t\t\t\t\tDescriptionFileUtils.getField(\n\t\t\t\t\t\t\t/** @type {JsonObject} */ (request.descriptionFileData),\n\t\t\t\t\t\t\tthis.fieldName,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\tif (!importsField) return callback();\n\n\t\t\t\tif (request.directory) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Resolving to directories is not possible with the imports field (request was ${remainingRequest}/)`,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t/** @type {string[]} */\n\t\t\t\tlet paths;\n\t\t\t\t/** @type {string | null} */\n\t\t\t\tlet usedField;\n\n\t\t\t\ttry {\n\t\t\t\t\t// We attach the cache to the description file instead of the importsField value\n\t\t\t\t\t// because we use a WeakMap and the importsField could be a string too.\n\t\t\t\t\t// Description file is always an object when exports field can be accessed.\n\t\t\t\t\tlet fieldProcessor = this.fieldProcessorCache.get(\n\t\t\t\t\t\t/** @type {JsonObject} */ (request.descriptionFileData),\n\t\t\t\t\t);\n\t\t\t\t\tif (fieldProcessor === undefined) {\n\t\t\t\t\t\tfieldProcessor = processImportsField(importsField);\n\t\t\t\t\t\tthis.fieldProcessorCache.set(\n\t\t\t\t\t\t\t/** @type {JsonObject} */ (request.descriptionFileData),\n\t\t\t\t\t\t\tfieldProcessor,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t[paths, usedField] = fieldProcessor(\n\t\t\t\t\t\tremainingRequest,\n\t\t\t\t\t\tthis.conditionNames,\n\t\t\t\t\t);\n\t\t\t\t} catch (/** @type {unknown} */ err) {\n\t\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t`Imports field in ${request.descriptionFilePath} can't be processed: ${err}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn callback(/** @type {Error} */ (err));\n\t\t\t\t}\n\n\t\t\t\tif (paths.length === 0) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Package import ${remainingRequest} is not imported from package ${request.descriptionFileRoot} (see imports field in ${request.descriptionFilePath})`,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tforEachBail(\n\t\t\t\t\tpaths,\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} path path\n\t\t\t\t\t * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback\n\t\t\t\t\t * @param {number} i index\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\t(path, callback, i) => {\n\t\t\t\t\t\tconst parsedIdentifier = parseIdentifier(path);\n\n\t\t\t\t\t\tif (!parsedIdentifier) return callback();\n\n\t\t\t\t\t\tconst [path_, query, fragment] = parsedIdentifier;\n\n\t\t\t\t\t\tswitch (path_.charCodeAt(0)) {\n\t\t\t\t\t\t\t// should be relative\n\t\t\t\t\t\t\tcase dotCode: {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tinvalidSegmentRegEx.exec(path_.slice(2)) !== null &&\n\t\t\t\t\t\t\t\t\tdeprecatedInvalidSegmentRegEx.test(path_.slice(2)) !== null\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tif (paths.length === i) {\n\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t`Invalid \"imports\" target \"${path}\" defined for \"${usedField}\" in the package config ${request.descriptionFilePath}, targets must start with \"./\"`,\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t/** @type {ResolveRequest} */\n\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\t\t\trequest: undefined,\n\t\t\t\t\t\t\t\t\tpath: resolver.join(\n\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (request.descriptionFileRoot),\n\t\t\t\t\t\t\t\t\t\tpath_,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\trelativePath: path_,\n\t\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\t\tfragment,\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\t\t\ttargetFile,\n\t\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\t\t`using imports field: ${path}`,\n\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t// Don't allow to continue - https://github.com/webpack/enhanced-resolve/issues/400\n\t\t\t\t\t\t\t\t\t\tif (result === undefined) return callback(null, null);\n\t\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// package resolving\n\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t/** @type {ResolveRequest} */\n\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\t\t\trequest: path_,\n\t\t\t\t\t\t\t\t\trelativePath: path_,\n\t\t\t\t\t\t\t\t\tfullySpecified: true,\n\t\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\t\tfragment,\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\t\t\ttargetPackage,\n\t\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\t\t`using imports field: ${path}`,\n\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t// Don't allow to continue - https://github.com/webpack/enhanced-resolve/issues/400\n\t\t\t\t\t\t\t\t\t\tif (result === undefined) return callback(null, null);\n\t\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {(null|Error)=} err error\n\t\t\t\t\t * @param {(null|ResolveRequest)=} result result\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\t(err, result) => callback(err, result || null),\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}