{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst {\n  parseIdentifier\n} = require(\"./identifier\");\n\n/** @typedef {string|(string|ConditionalMapping)[]} DirectMapping */\n/** @typedef {{[k: string]: MappingValue}} ConditionalMapping */\n/** @typedef {ConditionalMapping|DirectMapping|null} MappingValue */\n/** @typedef {Record<string, MappingValue>|ConditionalMapping|DirectMapping} ExportsField */\n/** @typedef {Record<string, MappingValue>} ImportsField */\n\n/**\n * Processing exports/imports field\n * @callback FieldProcessor\n * @param {string} request request\n * @param {Set<string>} conditionNames condition names\n * @returns {[string[], string | null]} resolved paths with used field\n */\n\n/*\nExample exports field:\n{\n  \".\": \"./main.js\",\n  \"./feature\": {\n    \"browser\": \"./feature-browser.js\",\n    \"default\": \"./feature.js\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\".\" and \"./feature\") as exports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n----------\n\nExample imports field:\n{\n  \"#a\": \"./main.js\",\n  \"#moment\": {\n    \"browser\": \"./moment/index.js\",\n    \"default\": \"moment\"\n  },\n  \"#moment/\": {\n    \"browser\": \"./moment/\",\n    \"default\": \"moment/\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\"#a\" and \"#moment/\", \"#moment\") as imports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n*/\n\nconst slashCode = \"/\".charCodeAt(0);\nconst dotCode = \".\".charCodeAt(0);\nconst hashCode = \"#\".charCodeAt(0);\nconst patternRegEx = /\\*/g;\n\n/**\n * @param {string} a first string\n * @param {string} b second string\n * @returns {number} compare result\n */\nfunction patternKeyCompare(a, b) {\n  const aPatternIndex = a.indexOf(\"*\");\n  const bPatternIndex = b.indexOf(\"*\");\n  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n  if (baseLenA > baseLenB) return -1;\n  if (baseLenB > baseLenA) return 1;\n  if (aPatternIndex === -1) return 1;\n  if (bPatternIndex === -1) return -1;\n  if (a.length > b.length) return -1;\n  if (b.length > a.length) return 1;\n  return 0;\n}\n\n/**\n * Trying to match request to field\n * @param {string} request request\n * @param {ExportsField | ImportsField} field exports or import field\n * @returns {[MappingValue, string, boolean, boolean, string]|null} match or null, number is negative and one less when it's a folder mapping, number is request.length + 1 for direct mappings\n */\nfunction findMatch(request, field) {\n  if (Object.prototype.hasOwnProperty.call(field, request) && !request.includes(\"*\") && !request.endsWith(\"/\")) {\n    const target = /** @type {{[k: string]: MappingValue}} */field[request];\n    return [target, \"\", false, false, request];\n  }\n\n  /** @type {string} */\n  let bestMatch = \"\";\n  /** @type {string|undefined} */\n  let bestMatchSubpath;\n  const keys = Object.getOwnPropertyNames(field);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const patternIndex = key.indexOf(\"*\");\n    if (patternIndex !== -1 && request.startsWith(key.slice(0, patternIndex))) {\n      const patternTrailer = key.slice(patternIndex + 1);\n      if (request.length >= key.length && request.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf(\"*\") === patternIndex) {\n        bestMatch = key;\n        bestMatchSubpath = request.slice(patternIndex, request.length - patternTrailer.length);\n      }\n    }\n    // For legacy `./foo/`\n    else if (key[key.length - 1] === \"/\" && request.startsWith(key) && patternKeyCompare(bestMatch, key) === 1) {\n      bestMatch = key;\n      bestMatchSubpath = request.slice(key.length);\n    }\n  }\n  if (bestMatch === \"\") return null;\n  const target = /** @type {{[k: string]: MappingValue}} */field[bestMatch];\n  const isSubpathMapping = bestMatch.endsWith(\"/\");\n  const isPattern = bestMatch.includes(\"*\");\n  return [target, (/** @type {string} */bestMatchSubpath), isSubpathMapping, isPattern, bestMatch];\n}\n\n/**\n * @param {ConditionalMapping | DirectMapping|null} mapping mapping\n * @returns {boolean} is conditional mapping\n */\nfunction isConditionalMapping(mapping) {\n  return mapping !== null && typeof mapping === \"object\" && !Array.isArray(mapping);\n}\n\n/**\n * @param {ConditionalMapping} conditionalMapping_ conditional mapping\n * @param {Set<string>} conditionNames condition names\n * @returns {DirectMapping | null} direct mapping if found\n */\nfunction conditionalMapping(conditionalMapping_, conditionNames) {\n  /** @type {[ConditionalMapping, string[], number][]} */\n  const lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];\n  loop: while (lookup.length > 0) {\n    const [mapping, conditions, j] = lookup[lookup.length - 1];\n    for (let i = j; i < conditions.length; i++) {\n      const condition = conditions[i];\n      if (condition === \"default\") {\n        const innerMapping = mapping[condition];\n        // is nested\n        if (isConditionalMapping(innerMapping)) {\n          const conditionalMapping = /** @type {ConditionalMapping} */\n          innerMapping;\n          lookup[lookup.length - 1][2] = i + 1;\n          lookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n          continue loop;\n        }\n        return /** @type {DirectMapping} */innerMapping;\n      }\n      if (conditionNames.has(condition)) {\n        const innerMapping = mapping[condition];\n        // is nested\n        if (isConditionalMapping(innerMapping)) {\n          const conditionalMapping = /** @type {ConditionalMapping} */\n          innerMapping;\n          lookup[lookup.length - 1][2] = i + 1;\n          lookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n          continue loop;\n        }\n        return /** @type {DirectMapping} */innerMapping;\n      }\n    }\n    lookup.pop();\n  }\n  return null;\n}\n\n/**\n * @param {string | undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} isPattern true, if mapping is a pattern (contains \"*\")\n * @param {boolean} isSubpathMapping true, for subpath mappings\n * @param {string} mappingTarget direct export\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string} mapping result\n */\nfunction targetMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, assert) {\n  if (remainingRequest === undefined) {\n    assert(mappingTarget, false);\n    return mappingTarget;\n  }\n  if (isSubpathMapping) {\n    assert(mappingTarget, true);\n    return mappingTarget + remainingRequest;\n  }\n  assert(mappingTarget, false);\n  let result = mappingTarget;\n  if (isPattern) {\n    result = result.replace(patternRegEx, remainingRequest.replace(/\\$/g, \"$$\"));\n  }\n  return result;\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} isPattern true, if mapping is a pattern (contains \"*\")\n * @param {boolean} isSubpathMapping true, for subpath mappings\n * @param {DirectMapping|null} mappingTarget direct export\n * @param {Set<string>} conditionNames condition names\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string[]} mapping result\n */\nfunction directMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, conditionNames, assert) {\n  if (mappingTarget === null) return [];\n  if (typeof mappingTarget === \"string\") {\n    return [targetMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, assert)];\n  }\n\n  /** @type {string[]} */\n  const targets = [];\n  for (const exp of mappingTarget) {\n    if (typeof exp === \"string\") {\n      targets.push(targetMapping(remainingRequest, isPattern, isSubpathMapping, exp, assert));\n      continue;\n    }\n    const mapping = conditionalMapping(exp, conditionNames);\n    if (!mapping) continue;\n    const innerExports = directMapping(remainingRequest, isPattern, isSubpathMapping, mapping, conditionNames, assert);\n    for (const innerExport of innerExports) {\n      targets.push(innerExport);\n    }\n  }\n  return targets;\n}\n\n/**\n * @param {ExportsField | ImportsField} field root\n * @param {(s: string) => string} normalizeRequest Normalize request, for `imports` field it adds `#`, for `exports` field it adds `.` or `./`\n * @param {(s: string) => string} assertRequest assertRequest\n * @param {(s: string, f: boolean) => void} assertTarget assertTarget\n * @returns {FieldProcessor} field processor\n */\nfunction createFieldProcessor(field, normalizeRequest, assertRequest, assertTarget) {\n  return function fieldProcessor(request, conditionNames) {\n    request = assertRequest(request);\n    const match = findMatch(normalizeRequest(request), field);\n    if (match === null) return [[], null];\n    const [mapping, remainingRequest, isSubpathMapping, isPattern, usedField] = match;\n\n    /** @type {DirectMapping | null} */\n    let direct = null;\n    if (isConditionalMapping(mapping)) {\n      direct = conditionalMapping(/** @type {ConditionalMapping} */mapping, conditionNames);\n\n      // matching not found\n      if (direct === null) return [[], null];\n    } else {\n      direct = /** @type {DirectMapping} */mapping;\n    }\n    return [directMapping(remainingRequest, isPattern, isSubpathMapping, direct, conditionNames, assertTarget), usedField];\n  };\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertExportsFieldRequest(request) {\n  if (request.charCodeAt(0) !== dotCode) {\n    throw new Error('Request should be relative path and start with \".\"');\n  }\n  if (request.length === 1) return \"\";\n  if (request.charCodeAt(1) !== slashCode) {\n    throw new Error('Request should be relative path and start with \"./\"');\n  }\n  if (request.charCodeAt(request.length - 1) === slashCode) {\n    throw new Error(\"Only requesting file allowed\");\n  }\n  return request.slice(2);\n}\n\n/**\n * @param {ExportsField} field exports field\n * @returns {ExportsField} normalized exports field\n */\nfunction buildExportsField(field) {\n  // handle syntax sugar, if exports field is direct mapping for \".\"\n  if (typeof field === \"string\" || Array.isArray(field)) {\n    return {\n      \".\": field\n    };\n  }\n  const keys = Object.keys(field);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key.charCodeAt(0) !== dotCode) {\n      // handle syntax sugar, if exports field is conditional mapping for \".\"\n      if (i === 0) {\n        while (i < keys.length) {\n          const charCode = keys[i].charCodeAt(0);\n          if (charCode === dotCode || charCode === slashCode) {\n            throw new Error(`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(key)})`);\n          }\n          i++;\n        }\n        return {\n          \".\": field\n        };\n      }\n      throw new Error(`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(key)})`);\n    }\n    if (key.length === 1) {\n      continue;\n    }\n    if (key.charCodeAt(1) !== slashCode) {\n      throw new Error(`Exports field key should be relative path and start with \"./\" (key: ${JSON.stringify(key)})`);\n    }\n  }\n  return field;\n}\n\n/**\n * @param {string} exp export target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertExportTarget(exp, expectFolder) {\n  const parsedIdentifier = parseIdentifier(exp);\n  if (!parsedIdentifier) {\n    return;\n  }\n  const [relativePath] = parsedIdentifier;\n  const isFolder = relativePath.charCodeAt(relativePath.length - 1) === slashCode;\n  if (isFolder !== expectFolder) {\n    throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(exp)} should end with \"/\"` : `Expecting file to file mapping. ${JSON.stringify(exp)} should not end with \"/\"`);\n  }\n}\n\n/**\n * @param {ExportsField} exportsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processExportsField = function processExportsField(exportsField) {\n  return createFieldProcessor(buildExportsField(exportsField), request => request.length === 0 ? \".\" : `./${request}`, assertExportsFieldRequest, assertExportTarget);\n};\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertImportsFieldRequest(request) {\n  if (request.charCodeAt(0) !== hashCode) {\n    throw new Error('Request should start with \"#\"');\n  }\n  if (request.length === 1) {\n    throw new Error(\"Request should have at least 2 characters\");\n  }\n  if (request.charCodeAt(1) === slashCode) {\n    throw new Error('Request should not start with \"#/\"');\n  }\n  if (request.charCodeAt(request.length - 1) === slashCode) {\n    throw new Error(\"Only requesting file allowed\");\n  }\n  return request.slice(1);\n}\n\n/**\n * @param {string} imp import target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertImportTarget(imp, expectFolder) {\n  const parsedIdentifier = parseIdentifier(imp);\n  if (!parsedIdentifier) {\n    return;\n  }\n  const [relativePath] = parsedIdentifier;\n  const isFolder = relativePath.charCodeAt(relativePath.length - 1) === slashCode;\n  if (isFolder !== expectFolder) {\n    throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(imp)} should end with \"/\"` : `Expecting file to file mapping. ${JSON.stringify(imp)} should not end with \"/\"`);\n  }\n}\n\n/**\n * @param {ImportsField} importsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processImportsField = function processImportsField(importsField) {\n  return createFieldProcessor(importsField, request => `#${request}`, assertImportsFieldRequest, assertImportTarget);\n};","map":{"version":3,"names":["parseIdentifier","require","slashCode","charCodeAt","dotCode","hashCode","patternRegEx","patternKeyCompare","a","b","aPatternIndex","indexOf","bPatternIndex","baseLenA","length","baseLenB","findMatch","request","field","Object","prototype","hasOwnProperty","call","includes","endsWith","target","bestMatch","bestMatchSubpath","keys","getOwnPropertyNames","i","key","patternIndex","startsWith","slice","patternTrailer","lastIndexOf","isSubpathMapping","isPattern","isConditionalMapping","mapping","Array","isArray","conditionalMapping","conditionalMapping_","conditionNames","lookup","loop","conditions","j","condition","innerMapping","push","has","pop","targetMapping","remainingRequest","mappingTarget","assert","undefined","result","replace","directMapping","targets","exp","innerExports","innerExport","createFieldProcessor","normalizeRequest","assertRequest","assertTarget","fieldProcessor","match","usedField","direct","assertExportsFieldRequest","Error","buildExportsField","charCode","JSON","stringify","assertExportTarget","expectFolder","parsedIdentifier","relativePath","isFolder","module","exports","processExportsField","exportsField","assertImportsFieldRequest","assertImportTarget","imp","processImportsField","importsField"],"sources":["C:/Users/dah03/calendar/mycalendar/node_modules/enhanced-resolve/lib/util/entrypoints.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst { parseIdentifier } = require(\"./identifier\");\n\n/** @typedef {string|(string|ConditionalMapping)[]} DirectMapping */\n/** @typedef {{[k: string]: MappingValue}} ConditionalMapping */\n/** @typedef {ConditionalMapping|DirectMapping|null} MappingValue */\n/** @typedef {Record<string, MappingValue>|ConditionalMapping|DirectMapping} ExportsField */\n/** @typedef {Record<string, MappingValue>} ImportsField */\n\n/**\n * Processing exports/imports field\n * @callback FieldProcessor\n * @param {string} request request\n * @param {Set<string>} conditionNames condition names\n * @returns {[string[], string | null]} resolved paths with used field\n */\n\n/*\nExample exports field:\n{\n  \".\": \"./main.js\",\n  \"./feature\": {\n    \"browser\": \"./feature-browser.js\",\n    \"default\": \"./feature.js\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\".\" and \"./feature\") as exports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n----------\n\nExample imports field:\n{\n  \"#a\": \"./main.js\",\n  \"#moment\": {\n    \"browser\": \"./moment/index.js\",\n    \"default\": \"moment\"\n  },\n  \"#moment/\": {\n    \"browser\": \"./moment/\",\n    \"default\": \"moment/\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\"#a\" and \"#moment/\", \"#moment\") as imports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n*/\n\nconst slashCode = \"/\".charCodeAt(0);\nconst dotCode = \".\".charCodeAt(0);\nconst hashCode = \"#\".charCodeAt(0);\nconst patternRegEx = /\\*/g;\n\n/**\n * @param {string} a first string\n * @param {string} b second string\n * @returns {number} compare result\n */\nfunction patternKeyCompare(a, b) {\n\tconst aPatternIndex = a.indexOf(\"*\");\n\tconst bPatternIndex = b.indexOf(\"*\");\n\tconst baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n\tconst baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n\n\tif (baseLenA > baseLenB) return -1;\n\tif (baseLenB > baseLenA) return 1;\n\tif (aPatternIndex === -1) return 1;\n\tif (bPatternIndex === -1) return -1;\n\tif (a.length > b.length) return -1;\n\tif (b.length > a.length) return 1;\n\n\treturn 0;\n}\n\n/**\n * Trying to match request to field\n * @param {string} request request\n * @param {ExportsField | ImportsField} field exports or import field\n * @returns {[MappingValue, string, boolean, boolean, string]|null} match or null, number is negative and one less when it's a folder mapping, number is request.length + 1 for direct mappings\n */\nfunction findMatch(request, field) {\n\tif (\n\t\tObject.prototype.hasOwnProperty.call(field, request) &&\n\t\t!request.includes(\"*\") &&\n\t\t!request.endsWith(\"/\")\n\t) {\n\t\tconst target = /** @type {{[k: string]: MappingValue}} */ (field)[request];\n\n\t\treturn [target, \"\", false, false, request];\n\t}\n\n\t/** @type {string} */\n\tlet bestMatch = \"\";\n\t/** @type {string|undefined} */\n\tlet bestMatchSubpath;\n\n\tconst keys = Object.getOwnPropertyNames(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\t\tconst patternIndex = key.indexOf(\"*\");\n\n\t\tif (patternIndex !== -1 && request.startsWith(key.slice(0, patternIndex))) {\n\t\t\tconst patternTrailer = key.slice(patternIndex + 1);\n\n\t\t\tif (\n\t\t\t\trequest.length >= key.length &&\n\t\t\t\trequest.endsWith(patternTrailer) &&\n\t\t\t\tpatternKeyCompare(bestMatch, key) === 1 &&\n\t\t\t\tkey.lastIndexOf(\"*\") === patternIndex\n\t\t\t) {\n\t\t\t\tbestMatch = key;\n\t\t\t\tbestMatchSubpath = request.slice(\n\t\t\t\t\tpatternIndex,\n\t\t\t\t\trequest.length - patternTrailer.length,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t// For legacy `./foo/`\n\t\telse if (\n\t\t\tkey[key.length - 1] === \"/\" &&\n\t\t\trequest.startsWith(key) &&\n\t\t\tpatternKeyCompare(bestMatch, key) === 1\n\t\t) {\n\t\t\tbestMatch = key;\n\t\t\tbestMatchSubpath = request.slice(key.length);\n\t\t}\n\t}\n\n\tif (bestMatch === \"\") return null;\n\n\tconst target = /** @type {{[k: string]: MappingValue}} */ (field)[bestMatch];\n\tconst isSubpathMapping = bestMatch.endsWith(\"/\");\n\tconst isPattern = bestMatch.includes(\"*\");\n\n\treturn [\n\t\ttarget,\n\t\t/** @type {string} */ (bestMatchSubpath),\n\t\tisSubpathMapping,\n\t\tisPattern,\n\t\tbestMatch,\n\t];\n}\n\n/**\n * @param {ConditionalMapping | DirectMapping|null} mapping mapping\n * @returns {boolean} is conditional mapping\n */\nfunction isConditionalMapping(mapping) {\n\treturn (\n\t\tmapping !== null && typeof mapping === \"object\" && !Array.isArray(mapping)\n\t);\n}\n\n/**\n * @param {ConditionalMapping} conditionalMapping_ conditional mapping\n * @param {Set<string>} conditionNames condition names\n * @returns {DirectMapping | null} direct mapping if found\n */\nfunction conditionalMapping(conditionalMapping_, conditionNames) {\n\t/** @type {[ConditionalMapping, string[], number][]} */\n\tconst lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];\n\n\tloop: while (lookup.length > 0) {\n\t\tconst [mapping, conditions, j] = lookup[lookup.length - 1];\n\n\t\tfor (let i = j; i < conditions.length; i++) {\n\t\t\tconst condition = conditions[i];\n\n\t\t\tif (condition === \"default\") {\n\t\t\t\tconst innerMapping = mapping[condition];\n\t\t\t\t// is nested\n\t\t\t\tif (isConditionalMapping(innerMapping)) {\n\t\t\t\t\tconst conditionalMapping = /** @type {ConditionalMapping} */ (\n\t\t\t\t\t\tinnerMapping\n\t\t\t\t\t);\n\t\t\t\t\tlookup[lookup.length - 1][2] = i + 1;\n\t\t\t\t\tlookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {DirectMapping} */ (innerMapping);\n\t\t\t}\n\n\t\t\tif (conditionNames.has(condition)) {\n\t\t\t\tconst innerMapping = mapping[condition];\n\t\t\t\t// is nested\n\t\t\t\tif (isConditionalMapping(innerMapping)) {\n\t\t\t\t\tconst conditionalMapping = /** @type {ConditionalMapping} */ (\n\t\t\t\t\t\tinnerMapping\n\t\t\t\t\t);\n\t\t\t\t\tlookup[lookup.length - 1][2] = i + 1;\n\t\t\t\t\tlookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {DirectMapping} */ (innerMapping);\n\t\t\t}\n\t\t}\n\n\t\tlookup.pop();\n\t}\n\n\treturn null;\n}\n\n/**\n * @param {string | undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} isPattern true, if mapping is a pattern (contains \"*\")\n * @param {boolean} isSubpathMapping true, for subpath mappings\n * @param {string} mappingTarget direct export\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string} mapping result\n */\nfunction targetMapping(\n\tremainingRequest,\n\tisPattern,\n\tisSubpathMapping,\n\tmappingTarget,\n\tassert,\n) {\n\tif (remainingRequest === undefined) {\n\t\tassert(mappingTarget, false);\n\n\t\treturn mappingTarget;\n\t}\n\n\tif (isSubpathMapping) {\n\t\tassert(mappingTarget, true);\n\n\t\treturn mappingTarget + remainingRequest;\n\t}\n\n\tassert(mappingTarget, false);\n\n\tlet result = mappingTarget;\n\n\tif (isPattern) {\n\t\tresult = result.replace(\n\t\t\tpatternRegEx,\n\t\t\tremainingRequest.replace(/\\$/g, \"$$\"),\n\t\t);\n\t}\n\n\treturn result;\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} isPattern true, if mapping is a pattern (contains \"*\")\n * @param {boolean} isSubpathMapping true, for subpath mappings\n * @param {DirectMapping|null} mappingTarget direct export\n * @param {Set<string>} conditionNames condition names\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string[]} mapping result\n */\nfunction directMapping(\n\tremainingRequest,\n\tisPattern,\n\tisSubpathMapping,\n\tmappingTarget,\n\tconditionNames,\n\tassert,\n) {\n\tif (mappingTarget === null) return [];\n\n\tif (typeof mappingTarget === \"string\") {\n\t\treturn [\n\t\t\ttargetMapping(\n\t\t\t\tremainingRequest,\n\t\t\t\tisPattern,\n\t\t\t\tisSubpathMapping,\n\t\t\t\tmappingTarget,\n\t\t\t\tassert,\n\t\t\t),\n\t\t];\n\t}\n\n\t/** @type {string[]} */\n\tconst targets = [];\n\n\tfor (const exp of mappingTarget) {\n\t\tif (typeof exp === \"string\") {\n\t\t\ttargets.push(\n\t\t\t\ttargetMapping(\n\t\t\t\t\tremainingRequest,\n\t\t\t\t\tisPattern,\n\t\t\t\t\tisSubpathMapping,\n\t\t\t\t\texp,\n\t\t\t\t\tassert,\n\t\t\t\t),\n\t\t\t);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst mapping = conditionalMapping(exp, conditionNames);\n\t\tif (!mapping) continue;\n\t\tconst innerExports = directMapping(\n\t\t\tremainingRequest,\n\t\t\tisPattern,\n\t\t\tisSubpathMapping,\n\t\t\tmapping,\n\t\t\tconditionNames,\n\t\t\tassert,\n\t\t);\n\t\tfor (const innerExport of innerExports) {\n\t\t\ttargets.push(innerExport);\n\t\t}\n\t}\n\n\treturn targets;\n}\n\n/**\n * @param {ExportsField | ImportsField} field root\n * @param {(s: string) => string} normalizeRequest Normalize request, for `imports` field it adds `#`, for `exports` field it adds `.` or `./`\n * @param {(s: string) => string} assertRequest assertRequest\n * @param {(s: string, f: boolean) => void} assertTarget assertTarget\n * @returns {FieldProcessor} field processor\n */\nfunction createFieldProcessor(\n\tfield,\n\tnormalizeRequest,\n\tassertRequest,\n\tassertTarget,\n) {\n\treturn function fieldProcessor(request, conditionNames) {\n\t\trequest = assertRequest(request);\n\n\t\tconst match = findMatch(normalizeRequest(request), field);\n\n\t\tif (match === null) return [[], null];\n\n\t\tconst [mapping, remainingRequest, isSubpathMapping, isPattern, usedField] =\n\t\t\tmatch;\n\n\t\t/** @type {DirectMapping | null} */\n\t\tlet direct = null;\n\n\t\tif (isConditionalMapping(mapping)) {\n\t\t\tdirect = conditionalMapping(\n\t\t\t\t/** @type {ConditionalMapping} */ (mapping),\n\t\t\t\tconditionNames,\n\t\t\t);\n\n\t\t\t// matching not found\n\t\t\tif (direct === null) return [[], null];\n\t\t} else {\n\t\t\tdirect = /** @type {DirectMapping} */ (mapping);\n\t\t}\n\n\t\treturn [\n\t\t\tdirectMapping(\n\t\t\t\tremainingRequest,\n\t\t\t\tisPattern,\n\t\t\t\tisSubpathMapping,\n\t\t\t\tdirect,\n\t\t\t\tconditionNames,\n\t\t\t\tassertTarget,\n\t\t\t),\n\t\t\tusedField,\n\t\t];\n\t};\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertExportsFieldRequest(request) {\n\tif (request.charCodeAt(0) !== dotCode) {\n\t\tthrow new Error('Request should be relative path and start with \".\"');\n\t}\n\tif (request.length === 1) return \"\";\n\tif (request.charCodeAt(1) !== slashCode) {\n\t\tthrow new Error('Request should be relative path and start with \"./\"');\n\t}\n\tif (request.charCodeAt(request.length - 1) === slashCode) {\n\t\tthrow new Error(\"Only requesting file allowed\");\n\t}\n\n\treturn request.slice(2);\n}\n\n/**\n * @param {ExportsField} field exports field\n * @returns {ExportsField} normalized exports field\n */\nfunction buildExportsField(field) {\n\t// handle syntax sugar, if exports field is direct mapping for \".\"\n\tif (typeof field === \"string\" || Array.isArray(field)) {\n\t\treturn { \".\": field };\n\t}\n\n\tconst keys = Object.keys(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\n\t\tif (key.charCodeAt(0) !== dotCode) {\n\t\t\t// handle syntax sugar, if exports field is conditional mapping for \".\"\n\t\t\tif (i === 0) {\n\t\t\t\twhile (i < keys.length) {\n\t\t\t\t\tconst charCode = keys[i].charCodeAt(0);\n\t\t\t\t\tif (charCode === dotCode || charCode === slashCode) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t)})`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\treturn { \".\": field };\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(\n\t\t\t\t\tkey,\n\t\t\t\t)})`,\n\t\t\t);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key.charCodeAt(1) !== slashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Exports field key should be relative path and start with \"./\" (key: ${JSON.stringify(\n\t\t\t\t\tkey,\n\t\t\t\t)})`,\n\t\t\t);\n\t\t}\n\t}\n\n\treturn field;\n}\n\n/**\n * @param {string} exp export target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertExportTarget(exp, expectFolder) {\n\tconst parsedIdentifier = parseIdentifier(exp);\n\n\tif (!parsedIdentifier) {\n\t\treturn;\n\t}\n\n\tconst [relativePath] = parsedIdentifier;\n\tconst isFolder =\n\t\trelativePath.charCodeAt(relativePath.length - 1) === slashCode;\n\n\tif (isFolder !== expectFolder) {\n\t\tthrow new Error(\n\t\t\texpectFolder\n\t\t\t\t? `Expecting folder to folder mapping. ${JSON.stringify(\n\t\t\t\t\t\texp,\n\t\t\t\t\t)} should end with \"/\"`\n\t\t\t\t: `Expecting file to file mapping. ${JSON.stringify(\n\t\t\t\t\t\texp,\n\t\t\t\t\t)} should not end with \"/\"`,\n\t\t);\n\t}\n}\n\n/**\n * @param {ExportsField} exportsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processExportsField = function processExportsField(\n\texportsField,\n) {\n\treturn createFieldProcessor(\n\t\tbuildExportsField(exportsField),\n\t\t(request) => (request.length === 0 ? \".\" : `./${request}`),\n\t\tassertExportsFieldRequest,\n\t\tassertExportTarget,\n\t);\n};\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertImportsFieldRequest(request) {\n\tif (request.charCodeAt(0) !== hashCode) {\n\t\tthrow new Error('Request should start with \"#\"');\n\t}\n\tif (request.length === 1) {\n\t\tthrow new Error(\"Request should have at least 2 characters\");\n\t}\n\tif (request.charCodeAt(1) === slashCode) {\n\t\tthrow new Error('Request should not start with \"#/\"');\n\t}\n\tif (request.charCodeAt(request.length - 1) === slashCode) {\n\t\tthrow new Error(\"Only requesting file allowed\");\n\t}\n\n\treturn request.slice(1);\n}\n\n/**\n * @param {string} imp import target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertImportTarget(imp, expectFolder) {\n\tconst parsedIdentifier = parseIdentifier(imp);\n\n\tif (!parsedIdentifier) {\n\t\treturn;\n\t}\n\n\tconst [relativePath] = parsedIdentifier;\n\tconst isFolder =\n\t\trelativePath.charCodeAt(relativePath.length - 1) === slashCode;\n\n\tif (isFolder !== expectFolder) {\n\t\tthrow new Error(\n\t\t\texpectFolder\n\t\t\t\t? `Expecting folder to folder mapping. ${JSON.stringify(\n\t\t\t\t\t\timp,\n\t\t\t\t\t)} should end with \"/\"`\n\t\t\t\t: `Expecting file to file mapping. ${JSON.stringify(\n\t\t\t\t\t\timp,\n\t\t\t\t\t)} should not end with \"/\"`,\n\t\t);\n\t}\n}\n\n/**\n * @param {ImportsField} importsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processImportsField = function processImportsField(\n\timportsField,\n) {\n\treturn createFieldProcessor(\n\t\timportsField,\n\t\t(request) => `#${request}`,\n\t\tassertImportsFieldRequest,\n\t\tassertImportTarget,\n\t);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}